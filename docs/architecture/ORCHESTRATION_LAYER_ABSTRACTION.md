# Orchestration Layer: Абстракція

> Створено: 2026-02-15
> Автор: Головний архітектор системи
> Статус: Канонічна специфікація
> Мова: Українська (канонічна)
> Частина: RUNTIME_ARCHITECTURE_INDEX.md

---

## 0. Призначення

Цей документ описує **Orchestration Layer** як абстрактний архітектурний компонент. Жоден vendor не є архітектурною залежністю. Документ визначає:

- Capabilities (що Orchestration Layer робить)
- Adapter Interface (контракт між системою та vendor)
- Заборони (що Orchestration Layer НЕ робить)
- Критерії вибору vendor

**[ПРИНЦИП]** Orchestration Layer — замінний компонент. Архітектура системи описується без vendor-specific термінів. Конкретна реалізація — деталь розгортання, не архітектурне рішення. Рекомендовані варіанти (за результатами дослідження 2026-02-21): **Hatchet** (MIT, FastAPI-native Python SDK, Hatchet Lite ~1-2 GB) або **Restate** (BUSL 1.1, single Rust binary ~256 MB, SDK MIT). Детальне порівняння — §6.

---

## 1. Capabilities

Orchestration Layer **повинен** реалізувати наступні capabilities:

### 1.1 Обов'язкові (P0)

| Capability | Опис | Застосування у системі |
|-----------|------|----------------------|
| **Event/trigger-driven запуск** | HTTP або event ініціює виконання задачі | Worker → trigger agent run |
| **Durable execution** | Крок зберігає стан; при збої — replay з останнього checkpoint | Захист від втрати прогресу при crash |
| **Step-based workflow** | Задача поділена на іменовані кроки з гарантією at-least-once | `load → query → propose → persist` |
| **Concurrency control** | Обмеження одночасних виконань per-task та глобально | Max 1 concurrent run per agent |
| **Scheduled execution** | Cron-based запуск задач за розкладом | Автоматичне виконання агентів |
| **Timeouts** | Per-step та per-task timeout | 120с per step, 600с per run |
| **Retries з backoff** | Автоматичне повторення при транзієнтних помилках | Max 3 retries, exponential backoff |

### 1.2 Бажані (P1)

| Capability | Опис | Застосування у системі |
|-----------|------|----------------------|
| **Step-level timeouts** | Таймаут окремого кроку (не лише загальний) | NLM-query може бути повільнішим |
| **Completion callback/webhook** | Повідомлення при завершенні задачі | Worker отримує notification |
| **Self-hosted deployment** | Можливість розгортання у власній інфраструктурі | Контроль даних |

### 1.3 Опціональні (P2)

| Capability | Опис | Застосування у системі |
|-----------|------|----------------------|
| **Queue position query** | API для запиту позиції у черзі | UI показує "Позиція: 3 з 5" |
| **Run dashboard** | Web UI для моніторингу виконання | DevOps та debugging |
| **Event replay** | Перезапуск конкретного event | Debugging та recovery |

---

## 2. Adapter Interface

### 2.1 Принцип

**[РІШЕННЯ]** Система взаємодіє з Orchestration Layer через **Adapter** — тонку абстракцію, що ізолює vendor-specific API від бізнес-логіки.

```
Worker → OrchestratorAdapter → [Vendor SDK] → Vendor Service
```

### 2.2 Контракт Adapter

Adapter повинен реалізувати наступний контракт:

```typescript
/**
 * Orchestration Layer Adapter Interface
 *
 * Vendor-agnostic контракт для координації виконання агентів.
 * Конкретна реалізація знаходиться у vendor-specific adapter.
 */
interface OrchestratorAdapter {
  /**
   * Ініціювати виконання агента.
   * Повертає run_id та початковий статус.
   */
  triggerAgentRun(params: {
    agent_slug: string;
    run_id: string;
    trigger: "manual" | "cron" | "event";
    params?: Record<string, unknown>;
  }): Promise<{ run_id: string; status: "requested" | "queued" }>;

  /**
   * Отримати статус виконання.
   * Adapter може читати з MinIO (canonical) або з vendor API.
   * MinIO є canonical source — vendor API лише fallback.
   */
  getRunStatus(run_id: string): Promise<RunStatus>;

  /**
   * Скасувати виконання (best-effort).
   * Не всі vendors підтримують cancellation.
   */
  cancelRun(run_id: string): Promise<{ cancelled: boolean }>;

  /**
   * Зареєструвати scheduled task (cron).
   */
  registerSchedule(params: {
    agent_slug: string;
    cron: string;
    enabled: boolean;
  }): Promise<void>;

  /**
   * Health check для orchestration service.
   */
  healthCheck(): Promise<{ healthy: boolean; vendor: string }>;
}
```

### 2.3 Status Writer Contract

**[ІНВАРІАНТ]** Orchestration Layer wrapper (не Mastra) є canonical writer для `status.json`.

Потік запису статусу:

```
Mastra виконує step → повертає результат Orchestration Layer
→ Orchestration Layer wrapper записує step result у MinIO
→ Orchestration Layer оновлює status.json
→ UI polling читає status.json через Worker
```

Це забезпечує:
- Єдиний writer для status (no race conditions)
- Mastra залишається stateless інтерпретатором
- Orchestration Layer контролює retry/timeout/concurrency

---

## 3. Task Definition

### 3.1 Agent Run Task

Canonical structure задачі agent-run:

```
Task: agent-run
  Input: { agent_slug, run_id, trigger, params }

  Step 1: load-context
    → Завантажити _agent.md та sources з MinIO
    → Завантажити memory Layer 1 (snapshot.md + open_loops.md) через Gateway
      (mode=basic ≤4100 токенів; mode=wide ≤13000 якщо агент вказав)
    → Записати step result у MinIO
    → Оновити status.json: running, step=1

  Step 2: execute-agent
    → Викликати Mastra agent з context (definition + sources + memory Layer 1)
    → Agent використовує tools (NLM, read-context, read-memory, etc.)
    → Записати step result у MinIO
    → Оновити status.json: step=2

  Step 3: persist-results
    → Зберегти content proposal(и) у MinIO {status: pending}
    → ЯКЩО агент виявив зміни в знаннях:
        POST /memory/{agentId}/propose {type: memory-update}
        (може бути auto-approved якщо priority=normal)
    → ЯКЩО оптимізатор пропонує logic-update:
        POST /logic/{agentId}/propose {type: logic-update, requiresHumanReview: true}
    → Записати step result у MinIO
    → Оновити status.json: step=3

  Step 4: finalize
    → Записати manifest.json (run summary)
    → Оновити status.json: completed

  On Error:
    → Retry з backoff (max 3)
    → Після exhaustion: status.json → failed
```

### 3.2 Scheduled Task

```
Task: agent-cron
  Schedule: визначається у agent config

  Step 1: resolve-agent
    → Прочитати agent config з MinIO
    → Перевірити enabled status

  Step 2: delegate
    → Trigger agent-run task з trigger="cron"
```

---

## 4. Заборони

Orchestration Layer **НЕ повинен:**

| Заборона | Обґрунтування |
|---------|--------------|
| Містити бізнес-логіку агентів | Бізнес-логіка живе у `_agent.md` → Mastra |
| Зберігати канонічні дані | Canonical storage = MinIO |
| Мати прямий доступ до frontend | Frontend → Worker → Orchestration Layer |
| Викликати NotebookLM напряму | NLM доступний лише як Mastra tool через FastAPI |
| Визначати поведінку агента | Поведінка = `_agent.md` + pseudocode |
| Змінювати MinIO layout | MinIO schema — архітектурний інваріант |

---

## 5. Критерії вибору vendor

При виборі конкретної реалізації Orchestration Layer, оцінювати:

| Критерій | Вага | Коментар |
|---------|------|---------|
| Durable execution з per-step replay | **Blocking** | Без цього — не підходить |
| HTTP trigger support | **Blocking** | Worker має ініціювати через HTTP |
| Per-task concurrency limits | **Blocking** | Agent isolation вимагає |
| Cron scheduling | **Blocking** | Automated agent runs |
| TypeScript/Node.js SDK | Висока | Agent Service = Node.js |
| Step-level timeouts | Середня | Fallback: загальний timeout |
| Self-hosted option | Середня | Для production control |
| Queue position API | Низька | Nice-to-have для UX |
| Managed cloud option | Низька | Для швидкого старту |

---

## 6. Vendor Notes

**[ПРИНЦИП]** Цей розділ містить implementation notes, не архітектурні рішення. Вибір vendor не впливає на архітектуру.

Результати дослідження (2026-02-21): порівняно 9 варіантів з фокусом на durable execution, Python/FastAPI-інтеграцію, ресурсні вимоги, open-source ліцензію.

| Vendor | Ліцензія | RAM (мін) | Durable Exec | FastAPI DX | Рекомендація |
|--------|---------|-----------|--------------|------------|-------------|
| **Hatchet** | MIT | ~1-2 GB (Lite) | ✅ Postgres-backed | ✅ Відмінний (FastAPI-style SDK) | **✅ Рекомендовано (primary)** |
| **Restate** | BUSL 1.1 (SDK: MIT) | ~256 MB | ✅ Event-sourced | Добрий | **✅ Рекомендовано (low-resource)** |
| Temporal | MIT | ~4-8 GB | ✅ Event-sourced | Добрий | Для production, якщо ресурси дозволяють |
| Prefect | Apache 2.0 (server: PCL) | ~2 GB | ⚠️ Частково | ✅ Відмінний | Альтернатива, але PCL-сервер |
| Celery+Redis | BSD | ~256 MB | ❌ Немає | ✅ Відмінний | Тільки для простих job queues |
| Trigger.dev v3 | Open-core | ~1 GB | Так | Добрий | Не рекомендовано (не Python-native) |

**Рекомендований вибір:**
- **Hatchet Lite** для $10-20/місяць VPS (4 GB RAM): MIT ліцензія, FastAPI-native Python SDK (`@hatchet.task()` декоратори), Postgres-backed durable execution
- **Restate** для мінімальних ресурсів (Raspberry Pi, $5 VPS): single binary ~256 MB, event-sourced durability, SDK MIT
- **Temporal** якщо є 8+ GB RAM і потрібна максимальна production-надійність

**Adapter Pattern:** незалежно від вибору vendor, система взаємодіє через `OrchestratorAdapter` інтерфейс (§2.2). Заміна vendor = нова реалізація адаптера без зміни бізнес-логіки.

**[РІШЕННЯ]** Конкретний vendor обирається на етапі реалізації. Документація canonical architecture не залежить від цього вибору.

---

## Див. також

- **RUNTIME_ARCHITECTURE_CANONICAL.md** — загальна canonical архітектура
- **RUN_LIFECYCLE_CANONICAL.md** — lifecycle стани run
- **EXECUTION_PIPELINE_CANONICAL.md** — pipeline виконання
- **RUNTIME_ARCHITECTURE_INDEX.md** — master index

---

## Семантичні зв'язки

**Цей документ деталізує:**
- [[ARCHITECTURE_ROOT]] — аксіома A4 (orchestration is replaceable): цей документ є її повним розкриттям

**Цей документ залежить від:**
- [[STORAGE_AUTHORITY_MODEL_CANONICAL]] — Hatchet wrapper є canonical status writer
- [[AGENT_MEMORY_GIT_DIFFMEM_V1]] — Task Definition Step 1: завантаження memory Layer 1
- [[INBOX_ТА_PROPOSAL_АРХІТЕКТУРА]] — Task Definition Step 3: persist-results → Proposal creation

**Від цього документа залежать:**
- [[EXECUTION_PIPELINE_CANONICAL]] — pipeline координується через Orchestration Layer
- [[RUN_LIFECYCLE_CANONICAL]] — state transitions встановлює Orchestration Layer wrapper
- [[RUNTIME_ARCHITECTURE_CANONICAL]] — деталізує роль Orchestration у загальній архітектурі

---

*Цей документ є канонічною специфікацією Orchestration Layer як абстрактного компонента. Він vendor-agnostic за задумом.*
