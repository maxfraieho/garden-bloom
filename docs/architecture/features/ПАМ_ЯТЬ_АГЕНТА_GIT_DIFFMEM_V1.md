---
tags:
  - domain:agent
  - status:canonical
  - format:spec
  - feature:memory
created: 2026-02-21
updated: 2026-02-21
tier: 1
title: "ПАМ ЯТЬ АГЕНТА GIT DIFFMEM V1"
dg-publish: true
dg-metatags:
dg-home:
---

# AGENT_MEMORY_GIT_DIFFMEM_V1

**Статус:** Канонічний  
**Версія:** 1.1.0  
**Дата:** 2026-02-17  
**Автор:** Головний архітектор, Garden Bloom  
**Розташування:** `docs/architecture/ПАМ_ЯТЬ_АГЕНТА_GIT_DIFFMEM_V1.md`  
**Мова:** Українська (технічна)

**Журнал змін версій:**
- `1.0.0` — початкова версія
- `1.1.0` — додано Секцію 11: Жорсткі ліміти пам'яті та модель витіснення (patch за зауваженням архітектора: запобігання експоненційному зростанню контексту)

---

> **Незмінний інваріант:** Цей документ є частиною канонічної документації рантайму.  
> Він НЕ посилається на `archive/`, НЕ містить посилань на Inngest або gh-aw.  
> Архітектура є вендор-агностичною.

> **⚠️ КРИТИЧНЕ ДОПОВНЕННЯ v1.1.0:** Секція 11 є обов'язковою до прочитання перед імплементацією.  
> Без жорстких лімітів витіснення система деградує експоненційно зі зростанням кількості запусків.

---

## ЗМІСТ

1. [Огляд DiffMem — внутрішня архітектура](#секція-1--огляд-diffmem--внутрішня-архітектура)
2. [Аналіз варіантів інтеграції](#секція-2--аналіз-варіантів-інтеграції)
3. [Канонічна структура файлів пам'яті](#секція-3--канонічна-структура-файлів-памяті)
4. [Модель доступу до пам'яті — дизайн інструментів](#секція-4--модель-доступу-до-памяті--дизайн-інструментів)
5. [Стратегія токен-економіки](#секція-5--стратегія-токен-економіки)
6. [Людський аудит та UX-модель](#секція-6--людський-аудит-та-ux-модель)
7. [Модель безпеки та збоїв](#секція-7--модель-безпеки-та-збоїв)
8. [Інтеграція з існуючим рантаймом Garden Bloom](#секція-8--інтеграція-з-існуючим-рантаймом-garden-bloom)
9. [План міграції](#секція-9--план-міграції)
10. [Фінальна рекомендація](#секція-10--фінальна-рекомендація)
11. [⚠️ Жорсткі ліміти пам'яті та модель витіснення (patch v1.1.0)](#секція-11--жорсткі-ліміти-памяті-та-модель-витіснення)

---

## СЕКЦІЯ 1 — Огляд DiffMem — внутрішня архітектура

### 1.1 Концепція

DiffMem — це легковагова git-орієнтована система пам'яті для ШІ-агентів. Вона реалізує принцип розділення між **поточним станом** (surface) та **еволюцією знань** (depth). Поточний стан зберігається у Markdown-файлах, а еволюція — в git-коммітах.

### 1.2 Ключові артефакти

DiffMem оперує такими артефактами:

- **Файли сутностей** (`notes/`) — Markdown-документи, що описують поточний стан знань: факти, відносини, рішення.
- **Git-коміти** — атомарні зміни стану, що формують повну хронологію еволюції пам'яті.
- **BM25-індекс** — побудований в пам'яті процесу пошуковий індекс для швидкого повнотекстового пошуку по поточних файлах.
- **Снепшоти** — точки збереження, що дозволяють відновити повний контекст на будь-який момент часу.

### 1.3 Модель снепшоту та дифу

DiffMem розрізняє два логічних шари:

**Поверхневий шар (surface):** Тільки актуальні файли, які завантажуються в контекст агента для поточного рядка. Мінімальний розмір = мінімальне споживання токенів.

**Глибинний шар (depth):** Git-коміти, `git log`, `git diff` — доступні лише за запитом. Агент може отримати: «Як цей факт змінювався протягом 30 днів?» — без завантаження всієї історії.

### 1.4 Модель читабельності для людини

Уся пам'ять зберігається у вигляді простого тексту (Markdown). Будь-яка зміна є git-дифом, доступним через стандартні git-інструменти. Людина може переглянути, відкоригувати або відкотити пам'ять агента в будь-який момент — без спеціального програмного забезпечення.

### 1.5 Сумісність з інваріантами Garden Bloom

DiffMem апріорно сумісний із системними інваріантами Garden Bloom:

- **Файл-базоване сховище** → DiffMem оперує виключно Markdown-файлами та git-репозиторіями.
- **Відсутність окремої БД** → BM25-індекс in-memory, не потребує Postgres або Redis.
- **Людський аудит** → git log є нативним механізмом аудиту.
- **Пропозиційний lifecycle** → кожна зміна пам'яті може проходити через Proposal lifecycle перед комітом.
- **Stateless runtime** → рантайм читає пам'ять, але не пише напряму.

### 1.6 Чому git-пам'ять підходить для агентів

Git є природним сховищем для пам'яті агентів з кількох причин:

По-перше, git нативно вирішує проблему версіонування без будь-якої додаткової інфраструктури. Кожен коміт є атомарним і незмінним записом, що унеможливлює непомічену мутацію пам'яті. По-друге, git-дифи — це найефективніший спосіб передати «що змінилось» мінімальною кількістю токенів. По-третє, git-репозиторій є повністю портабельним: він може зберігатися в MinIO як tar-архів, клонуватися, мігруватися без ризику втрати даних. Нарешті, людина і агент працюють з одним і тим самим форматом — Markdown + git — без будь-якого транслятора чи middleware.

---

## СЕКЦІЯ 2 — Аналіз варіантів інтеграції

### 2.1 Варіант A — Виділений git-репозиторій на кожного агента

#### Архітектурний опис

```
MinIO/
  agents-memory/
    <agentId>.git/       ← "bare" git репозиторій
    <agentId>.git.tar/   ← MinIO-об'єкт для зберігання

Рантайм (Mastra або інший):
  1. Завантажує <agentId>.git.tar із MinIO
  2. Розпаковує в /tmp/<runId>/<agentId>/
  3. Читає файли через read-memory()
  4. Формує Proposal для запису
  5. Gateway застосовує Proposal → git commit → re-pack → upload MinIO
```

Кожен агент має власний ізольований git-репозиторій. Зберігається в MinIO як tar-об'єкт. Рантайм розпаковує його в тимчасову директорію для роботи.

#### Оцінка

| Параметр | Оцінка |
|---|---|
| Авторитет сховища | MinIO (первинний), git (версіонування) |
| Аудитабельність | Висока — повний git log на агента |
| Масштабованість | Середня — N репозиторіїв = N tar-об'єктів |
| Безпека | Висока — ізоляція між агентами |
| Операційна складність | Середня — потребує pack/unpack логіки |
| Ефективність токенів | Висока — ізольований контекст на агента |
| Сумісність з Proposal lifecycle | Повна |

#### Ризики

Великі агенти з довгою пам'яттю можуть мати значний розмір tar-об'єкту. Операція clone/pack при кожному запуску додає латентність.

---

### 2.2 Варіант B — Монорепозиторій з папковою структурою `memory/<agentId>/`

#### Архітектурний опис

```
garden-bloom-memory/           ← один git-репозиторій
  memory/
    <agentId-1>/
      snapshot.md
      facts.md
      ...
    <agentId-2>/
      snapshot.md
      facts.md
      ...
  .git/                        ← спільна git-історія всіх агентів
```

Один репозиторій містить пам'ять усіх агентів. Зберігається в MinIO як єдиний bare-репозиторій або як git-клон на сервері рантайму.

#### Оцінка

| Параметр | Оцінка |
|---|---|
| Авторитет сховища | Git-репозиторій (первинний) + MinIO (резервна копія) |
| Аудитабельність | Висока — єдиний git log для всього проєкту |
| Масштабованість | Висока — єдиний репозиторій, без множення об'єктів |
| Безпека | Середня — потребує додаткового контролю доступу між агентами |
| Операційна складність | Низька — стандартний git workflow |
| Ефективність токенів | Висока — шляхи `memory/<agentId>/` дозволяють точкове завантаження |
| Сумісність з Proposal lifecycle | Повна |

#### Ризики

Конкурентні коміти від різних агентів можуть викликати merge-конфлікти. Відсутність ізоляції між агентами потребує явного access control на рівні шляхів.

---

### 2.3 Варіант C — Гібрид: MinIO як авторитет + periodичний git-снепшот

#### Архітектурний опис

```
MinIO (первинний авторитет):
  memory/<agentId>/snapshot.md    ← поточний стан
  memory/<agentId>/facts.md
  memory/<agentId>/decisions.md
  ...

Git-репозиторій (snapshot export):
  garden-bloom-memory-snapshots/
    memory/<agentId>/             ← копія з MinIO
    .git/
    ← коміт раз на добу або після кожного Proposal
```

MinIO є первинним авторитетом для read/write. Git-репозиторій є вторинним, синхронізованим через Proposal lifecycle. Агент читає з MinIO, пише через Proposal → Gateway → MinIO → git-sync job.

#### Оцінка

| Параметр | Оцінка |
|---|---|
| Авторитет сховища | MinIO (первинний), Git (аудит/snapshot) |
| Аудитабельність | Середня — git показує snapshots, не кожну зміну |
| Масштабованість | Висока — MinIO масштабується незалежно від git |
| Безпека | Висока — MinIO має власний access control |
| Операційна складність | Висока — два сховища, синхронізація |
| Ефективність токенів | Висока — MinIO читається напряму |
| Сумісність з Proposal lifecycle | Повна |

#### Ризики

Синхронізація між MinIO та git є додатковою точкою відмови. Якщо sync-job падає, git-аудит відстає від реального стану.

---

### 2.4 Порівняльна таблиця варіантів

| Критерій | Варіант A (окремий репо) | Варіант B (монорепо) | Варіант C (гібрид) |
|---|---|---|---|
| Авторитет сховища | MinIO + Git-tar | Git-монорепо | MinIO первинний |
| Аудитабельність | ★★★★★ | ★★★★★ | ★★★☆☆ |
| Масштабованість | ★★★☆☆ | ★★★★★ | ★★★★☆ |
| Ізоляція агентів | ★★★★★ | ★★★☆☆ | ★★★★☆ |
| Операційна складність | ★★★☆☆ | ★★★★★ | ★★☆☆☆ |
| Токен-ефективність | ★★★★★ | ★★★★★ | ★★★★☆ |
| Сумісність з Proposal | ★★★★★ | ★★★★★ | ★★★★★ |
| Відсутність БД | ✅ | ✅ | ✅ |
| Vendor lock-in | ❌ Ні | ❌ Ні | ❌ Ні |
| Рекомендація V1 | — | ✅ **Обрано** | — |

**Висновок секції:** Варіант B обраний як V1-канонічний підхід. Деталі обґрунтування — у Секції 10.

---

## СЕКЦІЯ 3 — Канонічна структура файлів пам'яті

### 3.1 Повна структура директорій

```
memory/
  <agentId>/
    snapshot.md
    facts.md
    open_loops.md
    decisions.md
    changelog.md
    timeline/
      2026-02-17.md
      2026-02-18.md
      ...
    runs/
      run_<id>.md
      ...
    meta.json
```

---

### 3.2 Опис кожного файлу

#### `snapshot.md`

**Призначення:** Стислий поточний стан агента. Є основним файлом, який завантажується при кожному запуску в якості «базового контексту». Відповідає на питання: «Хто я зараз, що я знаю, які мої активні задачі?»

**Формат:**
```markdown
# Snapshot: <agentId>
**Оновлено:** 2026-02-17T14:30:00Z
**Версія:** 42

## Роль
<опис ролі агента>

## Активний контекст
<поточні задачі, активні петлі>

## Ключові факти
<3-7 найважливіших фактів>

## Останні рішення
<2-3 останніх рішення>
```

**Частота запису:** При кожному завершенні запуску через Proposal.  
**Власник:** Proposal lifecycle (Gateway застосовує).  
**Розмір:** ≤ 2 000 токенів.  
**Утримання:** Зберігається постійно; попередні версії — в git-history.

---

#### `facts.md`

**Призначення:** Накопичений банк фактів — знань агента про домен, проєкт, контекст. Оновлюється інкрементально: нові факти додаються, застарілі — позначаються або видаляються через Proposal.

**Формат:**
```markdown
# Facts: <agentId>

## Домен
- <факт 1>
- <факт 2>

## Технічні знання
- <факт>

## Проєктний контекст
- <факт>

## Застаріло (архівовано git)
<!-- Ці рядки видаляються після коміту -->
```

**Частота запису:** При появі нових фактів (після кожного значущого запуску).  
**Власник:** Proposal lifecycle.  
**Розмір:** ≤ 8 000 токенів.  
**Утримання:** Постійно; видалені факти зберігаються в git-history.

---

#### `open_loops.md`

**Призначення:** Список відкритих питань, незавершених задач, очікувань — «петлі», які агент має пам'ятати між запусками.

**Формат:**
```markdown
# Open Loops: <agentId>

## Критичні
- [ ] <петля 1> — відкрита з 2026-02-15
- [ ] <петля 2>

## Очікування
- [ ] Підтвердження від <актор> щодо <тема>

## Закриті (останні 7 днів)
- [x] <петля> — закрита 2026-02-16 | run_<id>
```

**Частота запису:** При відкритті або закритті петлі.  
**Власник:** Proposal lifecycle.  
**Розмір:** ≤ 2 000 токенів.  
**Утримання:** Закриті петлі видаляються через 7 днів (зберігаються в git-history).

---

#### `decisions.md`

**Призначення:** Журнал архітектурних та операційних рішень, прийнятих агентом або в результаті його рекомендацій. Аналог ADR (Architecture Decision Record) для агентної пам'яті.

**Формат:**
```markdown
# Decisions: <agentId>

## 2026-02-17 — <назва рішення>
**Статус:** Прийнято
**Контекст:** <чому виникло питання>
**Рішення:** <що вирішено>
**Обґрунтування:** <чому>
**Наслідки:** <що змінилось>
**Run:** run_<id>
```

**Частота запису:** Лише при прийнятті значущого рішення.  
**Власник:** Proposal lifecycle (може ініціювати людина або агент через Proposal).  
**Розмір:** Необмежений (зростає з часом), але завантажується вибірково.  
**Утримання:** Постійно.

---

#### `changelog.md`

**Призначення:** Хронологічний лог змін стану агента — автоматично генерується при кожному коміті. Дозволяє людині швидко зрозуміти, «що змінилось» без читання повного git log.

**Формат:**
```markdown
# Changelog: <agentId>

## 2026-02-17

### 14:30 — run_abc123
- **facts.md:** Додано факт про MinIO конфігурацію
- **open_loops.md:** Закрито петлю "підтвердження Proposal lifecycle"
- **snapshot.md:** Оновлено активний контекст
```

**Частота запису:** Автоматично при кожному застосуванні Proposal.  
**Власник:** Gateway (автоматично).  
**Розмір:** ≤ 4 000 токенів (останні 30 записів; старіші — в git-history).  
**Утримання:** Ротація: зберігати 30 останніх записів у файлі, решта — в git.

---

#### `timeline/<дата>.md`

**Призначення:** Денний журнал активності агента. Один файл = один день. Дозволяє відтворити хронологію без читання git-history.

**Формат:**
```markdown
# Timeline: <agentId> / 2026-02-17

## Запуски

### 09:15 — run_abc123
**Тривалість:** 45с  
**Задача:** Аналіз Proposal #42  
**Результат:** Запропоновано оновлення facts.md  
**Proposal:** proposal_xyz789  
**Статус Proposal:** applied

### 14:30 — run_def456
...
```

**Частота запису:** Один запис при завершенні кожного запуску.  
**Власник:** Gateway (автоматично при застосуванні Proposal).  
**Розмір:** ≤ 2 000 токенів на файл.  
**Утримання:** Постійно (файли архівуються, не видаляються).

---

#### `runs/run_<id>.md`

**Призначення:** Детальний звіт конкретного запуску агента: вхідні дані, використані інструменти, проміжні результати, сформовані Proposals, фінальний вивід. Є першоджерелом для аудиту.

**Формат:**
```markdown
# Run: run_<id>
**Agent:** <agentId>  
**Час початку:** 2026-02-17T14:30:00Z  
**Час завершення:** 2026-02-17T14:30:45Z  
**Завдання:** <опис>

## Контекст (завантажений)
- snapshot.md (v42, 1200 токенів)
- facts.md (8000 токенів, фрагмент)

## Виконані кроки
1. read-memory(mode=basic)
2. <інструмент>(<аргументи>)
3. propose-memory-update(...)

## Сформовані Proposals
- proposal_<id>: оновлення facts.md

## Результат
<вивід агента>
```

**Частота запису:** Один файл на запуск (при завершенні, через Proposal).  
**Власник:** Рантайм генерує → Proposal lifecycle зберігає.  
**Розмір:** ≤ 8 000 токенів.  
**Утримання:** 90 днів; потім переносяться в архівну гілку git або в MinIO deep storage.

---

#### `meta.json`

**Призначення:** Машинно-читабельні метадані агента для швидкого завантаження без парсингу Markdown.

**Формат:**
```json
{
  "agentId": "<agentId>",
  "version": 42,
  "lastUpdate": "2026-02-17T14:30:00Z",
  "lastRunId": "run_abc123",
  "snapshotTokenCount": 1200,
  "factsTokenCount": 6800,
  "openLoopsCount": 3,
  "decisionsCount": 12,
  "schemaVersion": "1.0"
}
```

**Частота запису:** При кожному оновленні будь-якого файлу пам'яті.  
**Власник:** Gateway (автоматично).  
**Розмір:** < 500 байт.  
**Утримання:** Постійно (версіонується в git).

---

### 3.3 Зведена таблиця файлів

| Файл | Частота запису | Власник | Ліміт токенів | Утримання |
|---|---|---|---|---|
| `snapshot.md` | Кожен запуск | Proposal lifecycle | 2 000 | Постійно |
| `facts.md` | За необхідності | Proposal lifecycle | 8 000 | Постійно |
| `open_loops.md` | При змінах петель | Proposal lifecycle | 2 000 | 7 днів (закриті) |
| `decisions.md` | При рішеннях | Proposal lifecycle | Необмежено | Постійно |
| `changelog.md` | Кожен коміт | Gateway (авто) | 4 000 (ротація) | 30 записів |
| `timeline/<дата>.md` | Кожен запуск | Gateway (авто) | 2 000/день | Постійно |
| `runs/run_<id>.md` | Кожен запуск | Рантайм → Proposal | 8 000 | 90 днів |
| `meta.json` | Кожне оновлення | Gateway (авто) | ~100 токенів | Постійно |

---

## СЕКЦІЯ 4 — Модель доступу до пам'яті — дизайн інструментів

### 4.1 `read-memory()`

**Призначення:** Читання поточного стану пам'яті агента. Виконується рантаймом. Не потребує Proposal (це операція читання).

**Псевдо-JSON запит:**
```json
{
  "tool": "read-memory",
  "agentId": "garden-bloom-curator",
  "mode": "basic",
  "options": {
    "maxTokens": 4000,
    "includeFiles": ["snapshot.md", "open_loops.md"],
    "excludeFiles": ["runs/"]
  }
}
```

**Псевдо-JSON відповідь:**
```json
{
  "agentId": "garden-bloom-curator",
  "version": 42,
  "loadedAt": "2026-02-17T14:30:00Z",
  "mode": "basic",
  "tokenCount": 1480,
  "content": {
    "snapshot.md": "<зміст>",
    "open_loops.md": "<зміст>"
  },
  "meta": {
    "lastUpdate": "2026-02-17T14:29:00Z",
    "lastRunId": "run_abc123"
  }
}
```

**Режими читання:**

**`basic`** (≤ 2 000 токенів): Завантажує лише `snapshot.md` + `meta.json`. Використовується для швидкого відновлення контексту перед типовим запуском. Найбільш токен-ефективний режим.

**`wide`** (≤ 8 000 токенів): Завантажує `snapshot.md` + `facts.md` + `open_loops.md` + `decisions.md` (останні 5). Використовується для аналітичних запусків, де потрібен повний контекст.

**`deep`** (≤ 32 000 токенів): Завантажує всі файли поточного стану, включно з `changelog.md` та `timeline/` за останні 7 днів. Використовується для рефлексивних або налагоджувальних запусків.

**`temporal`** (налаштовується): Завантажує `snapshot.md` + вибрані git-дифи за вказаний часовий діапазон. Дозволяє агенту отримати відповідь на питання «що змінилось за останній тиждень?» без повного завантаження всієї пам'яті.

---

### 4.2 `propose-memory-update()`

**Призначення:** Формування Proposal на оновлення пам'яті агента. Рантайм ніколи не пише в пам'ять напряму — лише через цей інструмент.

**Псевдо-JSON запит:**
```json
{
  "tool": "propose-memory-update",
  "agentId": "garden-bloom-curator",
  "runId": "run_def456",
  "updates": [
    {
      "file": "facts.md",
      "operation": "append",
      "content": "- MinIO bucket mcpstorage підтримує versioning",
      "section": "Технічні знання"
    },
    {
      "file": "open_loops.md",
      "operation": "close",
      "loopId": "loop_001",
      "resolution": "Підтверджено через run_def456"
    },
    {
      "file": "snapshot.md",
      "operation": "replace",
      "content": "<новий зміст snapshot.md>"
    }
  ],
  "reasoning": "Виявлено нові технічні факти в процесі аналізу Proposal #42",
  "priority": "normal"
}
```

**Псевдо-JSON відповідь (від Gateway):**
```json
{
  "proposalId": "proposal_xyz789",
  "status": "pending",
  "agentId": "garden-bloom-curator",
  "createdAt": "2026-02-17T14:30:45Z",
  "estimatedApplyAt": "автоматично або після підтвердження людиною",
  "reviewUrl": "https://garden-mcp.exodus.pp.ua/proposals/proposal_xyz789"
}
```

**Примітки:**
- Proposal може бути автоматично затверджений (якщо `priority: normal` та `auto-approve: true` в конфігурації агента).
- Критичні зміни (`priority: high`) завжди вимагають підтвердження людиною.
- Після затвердження Gateway виконує git commit + оновлює `meta.json` + генерує запис у `changelog.md`.

---

### 4.3 `memory-diff()`

**Призначення:** Отримання git-дифу між двома версіями пам'яті агента. Використовується для аудиту або для надання агенту «що змінилось» контексту.

**Псевдо-JSON запит:**
```json
{
  "tool": "memory-diff",
  "agentId": "garden-bloom-curator",
  "from": "HEAD~5",
  "to": "HEAD",
  "files": ["facts.md", "decisions.md"],
  "format": "unified",
  "maxTokens": 2000
}
```

**Псевдо-JSON відповідь:**
```json
{
  "agentId": "garden-bloom-curator",
  "from": "abc1234",
  "to": "def5678",
  "fromDate": "2026-02-12T10:00:00Z",
  "toDate": "2026-02-17T14:30:00Z",
  "tokenCount": 840,
  "diff": {
    "facts.md": "--- a/facts.md\n+++ b/facts.md\n@@ ... @@\n+- MinIO bucket mcpstorage підтримує versioning",
    "decisions.md": "--- a/decisions.md\n+++ b/decisions.md\n@@ ... @@\n+## 2026-02-17 — ..."
  },
  "summary": "5 комітів, 3 файли змінені, +14 рядків, -2 рядки"
}
```

---

### 4.4 `memory-snapshot()`

**Призначення:** Примусове створення снепшоту поточного стану пам'яті. Використовується на початку великого запуску або перед міграцією.

**Псевдо-JSON запит:**
```json
{
  "tool": "memory-snapshot",
  "agentId": "garden-bloom-curator",
  "label": "pre-migration-v2",
  "includeRuns": false,
  "targetStorage": "minio",
  "path": "memory-snapshots/garden-bloom-curator/2026-02-17-pre-migration.tar.gz"
}
```

**Псевдо-JSON відповідь:**
```json
{
  "snapshotId": "snapshot_20260217_pre-migration",
  "agentId": "garden-bloom-curator",
  "createdAt": "2026-02-17T15:00:00Z",
  "gitCommit": "def5678",
  "size": "48KB",
  "storedAt": "minio://mcpstorage/memory-snapshots/garden-bloom-curator/2026-02-17-pre-migration.tar.gz",
  "restorable": true
}
```

---

### 4.5 Детерміністична побудова контексту

При виклику `read-memory(mode=basic)` рантайм завжди отримує той самий результат для одного і того ж `HEAD` коміту. Це гарантує:

- **Відтворюваність**: запуск агента з однаковим git-станом дає однаковий контекст.
- **Налагоджуваність**: людина може відтворити будь-який запуск, відновивши git-стан на момент запуску.
- **Токен-бюджетування**: рантайм знає заздалегідь кількість токенів у кожному режимі через `meta.json`.

---

### 4.6 Алгоритм токен-бюджетування

При запиті `read-memory()` рантайм виконує таку процедуру:

```
1. Читає meta.json (< 100 токенів)
2. Якщо snapshotTokenCount + openLoopsTokenCount ≤ maxTokens:
   → завантажує snapshot.md + open_loops.md
3. Якщо залишок бюджету дозволяє:
   → завантажує facts.md (або його фрагмент до ліміту)
4. Якщо mode=deep:
   → додає changelog.md + timeline/(сьогодні)
5. Ніколи не перевищує maxTokens
```

---

## СЕКЦІЯ 5 — Стратегія токен-економіки

### 5.1 Проблема поточного стану

У поточній архітектурі Garden Bloom NotebookLM є основним когнітивним шаром для агентів. Кожен запит до NotebookLM потребує передачі всього контексту знань, що призводить до:

- Значних витрат токенів на повторну передачу незмінного контексту.
- Залежності від зовнішнього сервісу (NotebookLM) для базових операцій пам'яті.
- Відсутності персистентної агентної пам'яті між сесіями.

### 5.2 Як git-пам'ять зменшує використання NotebookLM

Git-пам'ять дозволяє агенту мати **локальну, стислу, версіоновану версію** необхідного контексту. Замість того, щоб кожного разу звертатись до NotebookLM за «що я знаю про MinIO конфігурацію?», агент читає `facts.md` напряму.

NotebookLM залишається незамінним для:
- Семантичного пошуку по великому корпусу нотаток (Zettelkasten, Obsidian-база).
- Синтезу відповідей із множини первинних джерел.
- Запитань про знання, що не помістяться в `facts.md`.

### 5.3 Правила вибору джерела контексту

| Ситуація | Використовувати |
|---|---|
| Відновлення стану між запусками | `read-memory(mode=basic)` — тільки git |
| Перевірка відкритих задач | `open_loops.md` — тільки git |
| Перевірка прийнятих рішень | `decisions.md` — тільки git |
| Аналіз змін за тиждень | `memory-diff()` — тільки git |
| Пошук по канонічній базі знань | NotebookLM |
| Синтез із множини нотаток | NotebookLM |
| Відповідь на складне семантичне питання | NotebookLM |
| Аудит поточного стану + контекст нотаток | git (пам'ять) + NotebookLM |
| Простий запуск без потреби в нових знаннях | Тільки git-пам'ять (NotebookLM не викликається) |

### 5.4 Цільові розміри снепшотів

| Режим | Розмір | Призначення |
|---|---|---|
| `basic` | ≤ 2 000 токенів | Швидке відновлення, типові запуски |
| `wide` | ≤ 8 000 токенів | Аналітичні запуски, прийняття рішень |
| `deep` | ≤ 32 000 токенів | Рефлексія, налагодження, міграція |
| `temporal` | Налаштовується | Часові запити, аудит еволюції |

### 5.5 Алгоритм пріоритизації

При ініціалізації запуску агент виконує таку послідовність:

```
1. ЗАВЖДИ: read-memory(mode=basic) → ~2k токенів, нульова латентність до NotebookLM
2. ЯКЩО завдання вимагає знань поза пам'яттю:
   → query NotebookLM з цільовим питанням (не "дай весь контекст")
3. ЯКЩО NotebookLM повертає нові знання, релевантні агенту:
   → propose-memory-update() → зберегти в facts.md для майбутніх запусків
4. ЯКЩО завдання суто операційне (apply/status/route):
   → тільки git-пам'ять, NotebookLM не викликається
```

### 5.6 Очікувана економія

Для типового агента, що виконує 50 запусків на день:
- **До:** 50 × ~8 000 токенів контексту через NotebookLM = 400 000 токенів/день.
- **Після:** 50 × ~2 000 токенів з git + 10 запитів до NotebookLM × ~6 000 токенів = 160 000 токенів/день.
- **Скорочення:** ~60% загального споживання токенів.

---

## СЕКЦІЯ 6 — Людський аудит та UX-модель

### 6.1 Перегляд пам'яті агента

Людина може переглядати поточний стан пам'яті агента через будь-який з наступних способів:

**Через git-клієнт:**
```bash
cd garden-bloom-memory
cat memory/<agentId>/snapshot.md        # Поточний стан
cat memory/<agentId>/facts.md           # База фактів
git log --oneline memory/<agentId>/     # Хронологія змін
```

**Через майбутній Garden Bloom UI:**
Розділ «Пам'ять агентів» → вибір агента → вкладки: Snapshot / Факти / Петлі / Рішення / Хронологія.

**Через MinIO консоль:**
Перегляд файлів у `memory/<agentId>/` через стандартний S3-браузер.

### 6.2 Аудит змін

Git-history є первинним механізмом аудиту. Кожен коміт містить:
- Timestamp зміни (автоматично git).
- Ідентифікатор Proposal, що спричинив зміну (у повідомленні коміту).
- Ідентифікатор Run, що згенерував Proposal (у повідомленні коміту).
- Конкретні зміни у файлах (git diff).

**Формат повідомлення коміту:**
```
memory-update: <agentId> / run_<id> / proposal_<id>

Files: facts.md, open_loops.md, snapshot.md
Reason: Нові технічні факти виявлено в процесі аналізу Proposal #42
Auto-approved: true
```

### 6.3 Інспекція дифів

```bash
# Що змінилось за останній тиждень для агента?
git log --since="7 days ago" --oneline memory/<agentId>/

# Конкретний диф
git diff HEAD~3 HEAD -- memory/<agentId>/facts.md

# Стан пам'яті на конкретний момент
git show abc1234:memory/<agentId>/snapshot.md

# Хто/що змінювало decisions.md?
git log --follow --all -- memory/<agentId>/decisions.md
```

### 6.4 Трасування: Run → Proposal → Оновлення пам'яті

Повний ланцюг трасування:

```
1. run_<id>                          → runs/run_<id>.md
   ↓ містить посилання на
2. proposal_<id>                     → proposals/<id>.json (Gateway)
   ↓ після approve
3. git commit abc1234                → memory/<agentId>/ зміни
   ↓ містить посилання на
4. changelog.md запис                → читається людиною
   ↓
5. timeline/2026-02-17.md запис      → денна хронологія
```

Людина може почати з будь-якої точки ланцюга і пройти його в обох напрямках.

### 6.5 Ручне редагування пам'яті

Людина може редагувати файли пам'яті безпосередньо через git (commit вручну) або через Garden Bloom UI. Такий коміт матиме мітку `human-edit: true` у повідомленні і буде відрізнятися від автоматичних оновлень. Це є законним і бажаним механізмом корекції помилкових агентних записів.

---

## СЕКЦІЯ 7 — Модель безпеки та збоїв

### 7.1 Загрози та заходи захисту

#### Загроза 1: Prompt injection через пам'ять

**Опис:** Зловмисник може записати в `facts.md` або `snapshot.md` шкідливі інструкції, які будуть завантажені в контекст агента і змінять його поведінку.

**Пом'якшення:**
- Усі записи в пам'ять проходять через Proposal lifecycle — людина або система верифікації має схвалити зміни.
- Для автоматичного схвалення: Gateway застосовує санітизацію контенту (видалення HTML, перевірка формату Markdown).
- Для критичних агентів: `auto-approve: false` — усі зміни пам'яті вимагають ручного підтвердження.
- Моніторинг: незвично великі зміни `facts.md` (більше N рядків за один Proposal) автоматично позначаються для ручного перегляду.

#### Загроза 2: Пошкодження пам'яті (corrupted memory)

**Опис:** Файли пам'яті можуть бути пошкоджені через неправильно сформований Proposal, збій диску або помилку в логіці Gateway.

**Пом'якшення:**
- Git надає атомарний rollback до будь-якого попереднього коміту.
- MinIO зберігає резервні копії через Object versioning.
- Перед кожним застосуванням Proposal Gateway валідує Markdown-структуру файлів.
- `meta.json` містить контрольну суму (hash) останнього валідного стану.

**Відновлення:**
```bash
# Відкат до попереднього стану
git revert HEAD --no-edit
# або
git reset --hard HEAD~1
```

#### Загроза 3: Конкурентні оновлення пам'яті

**Опис:** Два запуски агента одночасно формують Proposals на оновлення одних і тих самих файлів.

**Пом'якшення:**
- Gateway обробляє Proposals послідовно (черга) для одного `agentId`.
- Система оптимістичного блокування: Proposal містить `expectedVersion` (версію з `meta.json`); Gateway відхиляє Proposal, якщо версія застаріла.
- Відхилений Proposal повертається зі статусом `conflict` → рантайм може перегенерувати Proposal на основі актуального стану.

**Псевдо-JSON конфлікту:**
```json
{
  "proposalId": "proposal_conflict_001",
  "status": "rejected",
  "reason": "version_conflict",
  "expectedVersion": 41,
  "currentVersion": 42,
  "resolution": "retry_with_latest"
}
```

#### Загроза 4: Конфлікти Proposals (proposal conflicts)

**Опис:** Два різних Proposals намагаються змінити один і той самий розділ одного файлу.

**Пом'якшення:**
- Gateway застосовує Proposals атомарно в порядку черги.
- При виявленні merge-конфлікту Gateway позначає обидва Proposals як `needs_human_review`.
- Людина вирішує конфлікт через UI або вручну через git.

#### Загроза 5: Несанкціонована мутація пам'яті

**Опис:** Рантайм або зовнішній агент намагається записати в `memory/<agentId>/` в обхід Proposal lifecycle.

**Пом'якшення:**
- Рантайм є stateless і не має прямого доступу до MinIO/git на запис (Інваріант 5).
- Gateway є єдиною точкою входу для мутацій (Інваріант 2).
- Доступ до MinIO-bucket обмежений: рантайм має права тільки на читання для `memory/`.
- Аудит: git-history незмінний; будь-який прямий запис мимо Gateway буде видно як «нез'ясований коміт без Proposal-посилання».

---

### 7.2 Матриця ризиків

| Загроза | Ймовірність | Вплив | Пом'якшення | Залишковий ризик |
|---|---|---|---|---|
| Prompt injection | Середня | Критичний | Proposal review + санітизація | Низький |
| Пошкодження файлів | Низька | Середній | Git rollback + MinIO versioning | Мінімальний |
| Конкурентні записи | Середня | Середній | Версійне блокування | Низький |
| Конфлікти Proposals | Низька | Низький | Людський перегляд | Мінімальний |
| Несанкціонована мутація | Низька | Критичний | Права доступу + аудит | Мінімальний |

---

## СЕКЦІЯ 8 — Інтеграція з існуючим рантаймом Garden Bloom

### 8.1 Взаємодія з Gateway (Cloudflare Worker)

Gateway отримує нові відповідальності в контексті агентної пам'яті:

**Нові ендпоінти:**
```
GET  /memory/:agentId/read?mode=basic       → read-memory()
POST /memory/:agentId/propose               → propose-memory-update()
GET  /memory/:agentId/diff?from=...&to=...  → memory-diff()
POST /memory/:agentId/snapshot              → memory-snapshot()
```

**Незмінні інваріанти, що зберігаються:**
- Інваріант 2: Gateway залишається єдиною точкою входу для мутацій пам'яті.
- Інваріант 3: Будь-яке оновлення пам'яті проходить через `pending → approved → applying → applied/failed`.

**Логіка Gateway при застосуванні memory-update Proposal:**
```
1. Валідує JWT-токен (агент або людина)
2. Перевіряє version conflict (meta.json)
3. Валідує структуру Markdown змін
4. Застосовує зміни до файлів
5. Виконує git commit з метаданими
6. Оновлює meta.json
7. Генерує запис у changelog.md
8. Генерує запис у timeline/<дата>.md
9. Повертає статус applied
```

### 8.2 Взаємодія з Proposal lifecycle

Proposal для оновлення пам'яті є звичайним Proposal — він проходить той самий lifecycle, що і будь-яка інша мутація в системі:

```
pending          → Proposal щойно сформований рантаймом
approved         → Людина або auto-approve схвалив
rejected         → Відхилено (конфлікт версії або людський відмов)
applying         → Gateway виконує git commit + файлові зміни
applied          → Зміни збережені, git-коміт виконаний
failed           → Помилка під час застосування (файл пошкоджений тощо)
```

Proposal-об'єкт для пам'яті містить додаткові поля:
```json
{
  "type": "memory-update",
  "agentId": "...",
  "runId": "...",
  "expectedVersion": 42,
  "updates": [...],
  "autoApprove": true,
  "priority": "normal"
}
```

### 8.3 Взаємодія з конвеєром виконання (Execution Pipeline)

Кожен запуск агента починається з кроку `read-memory()` і завершується кроком `propose-memory-update()` (якщо є що оновити):

```
[Execution Pipeline]

1. Ініціалізація запуску
   ↓
2. read-memory(mode=basic)          ← завантаження з git/MinIO
   ↓
3. [Основна логіка агента]
   ↓
4. [Опційно] query NotebookLM       ← якщо потрібен додатковий контекст
   ↓
5. Формування результату
   ↓
6. propose-memory-update()          ← якщо стан змінився
   ↓
7. Запис runs/run_<id>.md           ← через Proposal
   ↓
8. Завершення запуску
```

Рантайм (Mastra або інший оркестраційний адаптер) є stateless: він не зберігає стан між кроками. Уся персистентність — через Proposal → Gateway → git/MinIO.

**Інваріант 4 (Stateless runtime) зберігається:** Рантайм лише читає та пропонує — він ніколи не пише напряму.

### 8.4 Взаємодія з Оркестраційним шаром

Оркестраційний шар (vendor-agnostic абстракція) надає рантайму інструменти `read-memory()` та `propose-memory-update()` як частину стандартного набору агентних інструментів. Конкретна реалізація (Mastra, LangGraph, або інша) не має значення — контракт інструментів залишається незмінним.

**Інваріант 7 (Vendor-agnostic) зберігається:** Усі memory-операції визначені через абстрактний контракт JSON API, незалежний від конкретного оркестраційного фреймворку.

### 8.5 Взаємодія з канонічним сховищем (MinIO)

Для V1 (Варіант B) git-монорепозиторій `garden-bloom-memory` є первинним авторитетом для пам'яті. MinIO використовується для:

- Зберігання снепшотів: `memory-snapshots/<agentId>/<дата>.tar.gz`
- Зберігання run-файлів після ротації: `memory-archive/<agentId>/runs/<рік>/<місяць>/`
- Резервного копіювання git-репозиторію: `git-backup/garden-bloom-memory.bundle`

**Інваріант 1 (File-based canonical storage) зберігається:** MinIO і git є файловими сховищами без будь-яких окремих БД.

---

## СЕКЦІЯ 9 — План міграції

### Фаза 0 — Тільки документація (ЗАРАЗ)

**Тривалість:** 1-2 тижні  
**Ризик:** Нульовий  
**Оборотність:** 100%

**Дії:**
- Публікація цього документу як канонічного (`docs/architecture/ПАМ_ЯТЬ_АГЕНТА_GIT_DIFFMEM_V1.md`).
- Ознайомлення команди з концепцією.
- Жодних змін у рантаймі, коді або інфраструктурі.

**Критерій завершення:** Документ прийнятий командою.

---

### Фаза 1 — Введення файлової структури пам'яті

**Тривалість:** 1 тиждень  
**Ризик:** Мінімальний  
**Оборотність:** 100%

**Дії:**
- Створити git-репозиторій `garden-bloom-memory` (порожній або локально).
- Додати директорії `memory/<agentId>/` для існуючих агентів.
- Вручну наповнити `snapshot.md` і `facts.md` поточним відомим контекстом агентів.
- Зберегти репозиторій у MinIO як резервну копію.

**Жодних змін у рантаймі.** Пам'ять поки що читається лише людьми.

**Критерій завершення:** Файли пам'яті існують, людина може їх читати.

---

### Фаза 2 — Введення інструментів пам'яті (read-only)

**Тривалість:** 2 тижні  
**Ризик:** Низький  
**Оборотність:** Проста — видалити інструменти

**Дії:**
- Реалізувати `read-memory()` в Gateway (тільки читання).
- Реалізувати `memory-diff()` в Gateway.
- Підключити ці інструменти до оркестраційного шару як опціональні.
- Провести тестові запуски агентів з `read-memory(mode=basic)`.

**Запис у пам'ять поки що відсутній.** Агент читає, але не пише.

**Критерій завершення:** Рантайм успішно читає `snapshot.md` через Gateway.

---

### Фаза 3 — Агенти починають писати пам'ять через Proposals

**Тривалість:** 2-4 тижні  
**Ризик:** Середній  
**Оборотність:** Зупинити auto-approve, перейти на ручний огляд

**Дії:**
- Реалізувати `propose-memory-update()` в Gateway.
- Реалізувати Proposal lifecycle для type=`memory-update`.
- Запустити для одного пілотного агента з `auto-approve: false`.
- Кожен Proposal оглядається людиною протягом 2 тижнів.
- Після підтвердження якості → увімкнути `auto-approve: true` для normal-пріоритету.

**Критерій завершення:** Агент успішно оновлює пам'ять через Proposal; якість записів прийнятна.

---

### Фаза 4 — Зменшення залежності від NotebookLM

**Тривалість:** 4-8 тижнів  
**Ризик:** Низький (NotebookLM залишається доступним)  
**Оборотність:** Завжди можна повернутись до NotebookLM

**Дії:**
- Впровадити логіку вибору джерела контексту (Секція 5.3).
- Типові запуски агентів переводяться на `read-memory(mode=basic)` без NotebookLM.
- NotebookLM залишається для семантичного пошуку та синтезу.
- Вимірювати споживання токенів до/після.

**Критерій завершення:** ≥ 50% запусків агентів не потребують NotebookLM.

---

### Фаза 5 — Повне виробниче використання

**Тривалість:** Постійно  
**Ризик:** Стандартний виробничий ризик

**Дії:**
- Усі агенти використовують git-пам'ять.
- Реалізовано ротацію `runs/` (90 днів).
- Реалізовано `memory-snapshot()` для резервного копіювання.
- NotebookLM використовується лише там, де дійсно потрібен (Секція 5.3).
- Моніторинг розміру репозиторію та якості пам'яті.

**Критерій завершення:** Git-пам'ять є основним механізмом персистентного контексту агентів.

---

### Таблиця зворотності фаз

| Фаза | Зворотність | Метод відкату |
|---|---|---|
| 0 | 100% | Видалити документ |
| 1 | 100% | Видалити файли |
| 2 | Проста | Відключити інструменти |
| 3 | Проста | Вимкнути auto-approve |
| 4 | Проста | Повернути виклики до NotebookLM |
| 5 | Середня | Поступовий перехід |

---

## СЕКЦІЯ 10 — ФІНАЛЬНА РЕКОМЕНДАЦІЯ

### 10.1 Обраний підхід: Варіант B — Монорепозиторій `garden-bloom-memory`

**V1 Канонічна архітектура агентної пам'яті для Garden Bloom — це git-монорепозиторій з папковою структурою `memory/<agentId>/`, що зберігається у поточній git-інфраструктурі проєкту та резервується в MinIO.**

### 10.2 Технічне обґрунтування

**1. Операційна простота.** Монорепозиторій є найпростішою операційною моделлю: один репозиторій, стандартний git workflow, жодного pack/unpack, жодної мультиплікації об'єктів у MinIO. Для V1 це критично — архітектура повинна бути зрозумілою і підтримуваною без спеціальної інфраструктури.

**2. Повна відповідність системним інваріантам.** Монорепозиторій з Proposal lifecycle для записів повністю відповідає всім 10 системним інваріантам Garden Bloom без виключень. Рантайм залишається stateless, Gateway є єдиною точкою мутацій, файлове зберігання без БД — усе це нативно забезпечується git.

**3. Людська аудитабельність.** Git log є найбільш читабельним і стандартним механізмом аудиту. Людина з мінімальними знаннями git може перевірити будь-яку зміну в пам'яті агента. Монорепозиторій дає ще й перевагу єдиної точки огляду: `git log memory/` показує всі зміни всіх агентів хронологічно.

**4. Токен-ефективність.** Завантаження `snapshot.md` ≤ 2 000 токенів на початку кожного запуску дозволяє агенту мати повний контекст без звернення до NotebookLM у більшості сценаріїв. Це безпосередньо знижує операційні витрати системи.

**5. Відсутність vendor lock-in.** Git є відкритим стандартом. MinIO — S3-сумісний відкритий сервіс. Markdown — простий текст. Ця архітектура може бути перенесена на будь-яку інфраструктуру без переписування коду.

**6. Масштабованість.** Git-монорепозиторій ефективно масштабується до сотень агентів і тисяч комітів завдяки pack-файлам та shallow clone. При досягненні меж масштабу (десятки тисяч агентів) завжди можна мігрувати на Варіант A з мінімальними змінами у контрактах інструментів.

**7. Безпечний поетапний rollout.** Варіант B дозволяє почати з Фази 0 (тільки документація) і поступово ввести функціональність без жодного ризику для поточного рантайму.

### 10.3 Чому не Варіант A і не Варіант C

**Варіант A** (окремий репозиторій на агента) більш придатний для production-систем з тисячами ізольованих агентів. Для поточного масштабу Garden Bloom він є зайвою складністю: pack/unpack tar-об'єктів при кожному запуску додає латентність, мультиплікація об'єктів у MinIO ускладнює операційний огляд.

**Варіант C** (гібрид MinIO + periodic git snapshot) порушує принцип єдиного авторитету: два сховища з власними стратегіями консистентності підвищують ризик розбіжності між «реальним станом» (MinIO) та «аудитним станом» (git). Для системи, де аудитабельність є ключовою вимогою, це є неприйнятним компромісом.

### 10.4 Визначення «успіху» V1

V1 вважається успішним, якщо:

1. Принаймні один агент успішно читає `snapshot.md` на початку запуску.
2. Принаймні один Proposal типу `memory-update` успішно проходить повний lifecycle.
3. Людина може прочитати git log і зрозуміти хронологію змін пам'яті агента.
4. Жоден з 10 системних інваріантів не порушений.
5. NotebookLM залишається функціональним як опціональний шар — git-пам'ять не замінює, а доповнює його.

---

## СЕКЦІЯ 11 — ⚠️ Жорсткі ліміти пам'яті та модель витіснення

> **Patch v1.1.0 — обов'язковий до імплементації.**  
> Ця секція виправляє критичний архітектурний ризик, виявлений після публікації v1.0.0:  
> без жорстких лімітів та механізму витіснення пам'ять агента зростає необмежено,  
> що призводить до **експоненційного уповільнення** та деградації якості відповідей.

---

### 11.1 Опис ризику

Папка агента є його «знанням» — але якщо в це знання потрапляє **вся історія транзакцій** (runs, changelog, timeline), то з часом відбувається наступне:

```
Запуск   1:  контекст =   2 000 токенів  ← нормально
Запуск 100:  контекст =  50 000 токенів  ← повільно
Запуск 500:  контекст = 250 000 токенів  ← колапс
```

Агент починає «знати» занадто багато **нерелевантного** — старі петлі, застарілі факти, деталі давніх запусків. Контекстний шум витісняє корисний сигнал. Це аналог людини, яка намагається прийняти рішення, перечитуючи всі свої щоденники за 10 років.

---

### 11.2 Канонічна двошарова модель (обов'язкова)

Усі файли пам'яті поділяються на **два шари з різними правилами доступу**:

```
╔══════════════════════════════════════════════════════╗
║  ШАР 1 — «ЖИВА ПАМ'ЯТЬ»  (завантажується автоматично)  ║
║                                                      ║
║  snapshot.md      ≤  2 000 токенів  HARD LIMIT       ║
║  facts.md         ≤  8 000 токенів  HARD LIMIT       ║
║  open_loops.md    ≤  2 000 токенів  HARD LIMIT       ║
║                                                      ║
║  ЗАГАЛЬНИЙ ЛІМІТ: ≤ 12 000 токенів                   ║
╚══════════════════════════════════════════════════════╝

╔══════════════════════════════════════════════════════╗
║  ШАР 2 — «МЕРТВИЙ АРХІВ»  (тільки за явним запитом) ║
║                                                      ║
║  decisions.md     — тільки останні 5 за запитом      ║
║  changelog.md     — тільки для аудиту людиною        ║
║  timeline/<дата>  — тільки temporal-режим            ║
║  runs/run_<id>    — тільки explicit memory-diff()    ║
╚══════════════════════════════════════════════════════╝
```

**Правило:** агент при ініціалізації запуску **НІКОЛИ** автоматично не завантажує Шар 2. Шар 2 існує виключно для людського аудиту та цільових temporal-запитів.

---

### 11.3 Механізм витіснення (eviction)

Коли будь-який файл Шару 1 досягає свого HARD LIMIT, Gateway **зобов'язаний** виконати витіснення перед застосуванням нового Proposal:

#### Витіснення `facts.md` (ліміт 8 000 токенів)

```
Алгоритм витіснення facts.md:

1. Виміряти поточний розмір facts.md в токенах
2. ЯКЩО після додавання новий розмір > 8 000:
   а. Відсортувати факти за ознакою «останнє використання»
      (агент позначає факт як використаний при read-memory)
   б. Факти, не використані > 30 днів → перенести в git-history
      (видалити з файлу, коміт із поміткою "evicted: stale-fact")
   в. ЯКЩО після витіснення все ще > 8 000:
      → Залишити тільки топ-N найновіших фактів
      → Решта — в git-history
3. Застосувати новий Proposal
```

#### Витіснення `open_loops.md` (ліміт 2 000 токенів)

```
1. Закриті петлі видаляються через 7 днів (вже визначено в v1.0.0)
2. ЯКЩО відкритих петель > 2 000 токенів:
   → Петлі з пріоритетом "low" + вік > 14 днів → переносяться
     в decisions.md як "заморожені" і видаляються з open_loops.md
```

#### Витіснення `snapshot.md` (ліміт 2 000 токенів)

```
snapshot.md НЕ накопичується — він ЗАМІНЮЄТЬСЯ повністю при кожному
оновленні. Gateway відхиляє Proposal, якщо новий snapshot.md > 2 000 токенів.
Агент зобов'язаний стиснути snapshot до ліміту перед пропозицією.
```

---

### 11.4 Правило «Агент не бачить свою історію»

Це є **жорстким архітектурним правилом**, а не рекомендацією:

> **Рантайм НІКОЛИ не передає в контекст агента файли з Шару 2 без явного запиту.**

Порушення цього правила є помилкою імплементації, а не конфігурації.

Конкретно заборонено без явного запиту:
- Автоматичне завантаження `runs/` будь-якого розміру
- Автоматичне завантаження `timeline/` будь-якого дня
- Автоматичне завантаження `changelog.md`
- Автоматичне завантаження `decisions.md` повністю (тільки останні 5)

---

### 11.5 Поправка до таблиці файлів (Секція 3.3)

Наступні рядки таблиці в Секції 3.3 вважаються заміненими цією секцією:

| Файл | Ліміт токенів (v1.0.0) | Ліміт токенів (v1.1.0) | Шар |
|---|---|---|---|
| `snapshot.md` | ≤ 2 000 | ≤ 2 000 **HARD** (відхилення при перевищенні) | 1 |
| `facts.md` | ≤ 8 000 | ≤ 8 000 **HARD** (витіснення при перевищенні) | 1 |
| `open_loops.md` | ≤ 2 000 | ≤ 2 000 **HARD** (заморожування при перевищенні) | 1 |
| `decisions.md` | Необмежено | Необмежено у файлі, але **завантажується max 5** | 2 |
| `changelog.md` | 4 000 (ротація) | Тільки людський аудит, **не завантажується агентом** | 2 |
| `timeline/<дата>.md` | ≤ 2 000/день | Тільки temporal-запит, **не завантажується автоматично** | 2 |
| `runs/run_<id>.md` | ≤ 8 000 | Тільки explicit-запит, **не завантажується автоматично** | 2 |

---

### 11.6 Поправка до алгоритму токен-бюджетування (Секція 4.6)

Алгоритм з Секції 4.6 замінюється наступним:

```
read-memory(mode=basic):
  1. Читає meta.json (< 100 токенів)
  2. ПЕРЕВІРЯЄ: чи всі файли Шару 1 в межах HARD LIMIT?
     ЯКЩО НІ → ініціює eviction-Proposal (автоматично, auto-approve: true)
  3. Завантажує snapshot.md (≤ 2 000)
  4. Завантажує open_loops.md (≤ 2 000)
  5. ГАРАНТОВАНИЙ максимум: 4 100 токенів

read-memory(mode=wide):
  1-4. Те саме, що basic
  5. Завантажує facts.md (≤ 8 000)
  6. Завантажує decisions.md ТІЛЬКИ останні 5 записів
  7. ГАРАНТОВАНИЙ максимум: 13 000 токенів

read-memory(mode=deep | temporal):
  → Виконується ТІЛЬКИ за явним запитом агента або людини
  → Завантажує файли Шару 2 цільово
  → НЕ є режимом за замовчуванням
```

---

### 11.7 Аналогія з мозком

Цей механізм відповідає тому, як людська пам'ять реально працює: мозок не зберігає кожну деталь кожного дня у «швидкому доступі». Він зберігає **стиснутий поточний стан** (snapshot) і **ключові факти** (facts), а деталі подій поступово переходять у довготривалу пам'ять або забуваються. Детальне відтворення конкретного спогаду (temporal-запит) — це окрема когнітивна операція, а не фоновий процес.

Git-history в цій архітектурі — це довготривала пам'ять агента. Вона існує, вона повна, але вона не навантажує «робочу пам'ять» (контекстне вікно) при кожній дії.

---

## ДОДАТОК А — Перевірочний список відповідності інваріантам

| Інваріант | Статус | Пояснення |
|---|---|---|
| 1. Канонічне сховище файл-базоване | ✅ | git + MinIO, без БД |
| 2. Gateway — єдина точка мутацій | ✅ | Усі memory-write через Gateway |
| 3. Proposal lifecycle обов'язковий | ✅ | type=memory-update проходить повний lifecycle |
| 4. Runtime stateless | ✅ | Рантайм лише читає і пропонує |
| 5. Runtime не пише canonical storage | ✅ | Тільки read-memory() без запису |
| 6. Runtime не пише status.json | ✅ | status.json не задіяний |
| 7. Vendor-agnostic orchestration | ✅ | JSON API контракт незалежний від фреймворку |
| 8. docs/ — канонічний корінь документації | ✅ | Документ розташований в docs/architecture/ |
| 9. archive/ не використовується | ✅ | Жодних посилань на archive/ |
| 10. NotebookLM опціональний | ✅ | Git-пам'ять основна, NotebookLM доповнює |

**Всі 10 інваріантів збережені. ✅**

---

## ДОДАТОК Б — Заборонені посилання (перевірка)

| Заборонена сутність | Статус |
|---|---|
| Inngest | ❌ Відсутній |
| gh-aw | ❌ Відсутній |
| PostgreSQL / Postgres | ❌ Відсутній |
| Redis | ❌ Відсутній |
| archive/ | ❌ Відсутній |
| Vendor lock-in | ❌ Відсутній |

**Усі заборонені посилання відсутні. ✅**

---

*Документ є канонічним і стає частиною рантайм-архітектури Garden Bloom з моменту публікації.*
*Наступний перегляд: при переході до Фази 3 плану міграції.*

---

## Семантичні зв'язки

**Цей документ деталізує:**
- [[АРХІТЕКТУРНИЙ_КОРІНЬ]] — аксіома A7 (bounded memory, git monorepo, HARD limits), частина A1 (git monorepo як source of truth)

**Цей документ залежить від:**
- [[КАНОНІЧНА_МОДЕЛЬ_АВТОРИТЕТУ_СХОВИЩА]] — git monorepo як storage tier (§1, Tier 1 та Tier 2)
- [[INBOX_ТА_PROPOSAL_АРХІТЕКТУРА]] — memory-update Proposal: єдиний механізм запису у memory/

**Від цього документа залежать:**
- [[КОНТРАКТ_АГЕНТА_V1]] — §1.3 memory constraint, §6.4 memory format
- [[АБСТРАКЦІЯ_РІВНЯ_ОРКЕСТРАЦІЇ]] — Task Definition Step 1: завантаження Layer 1
- [[КАНОНІЧНИЙ_КОНВЕЄР_ВИКОНАННЯ]] — Phase 3 (Context Load): memory Layer 1 via Gateway
- [[ВЕРСІОНУВАННЯ_ЛОГІКИ_АГЕНТА_V1]] — суміжний storage tier у тому самому git monorepo
