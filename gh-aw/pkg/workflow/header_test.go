//go:build !integration

package workflow

import (
	"strings"
	"testing"
)

func TestGenerateWorkflowHeader_VersionInDevBuild(t *testing.T) {
	// Save original version
	originalVersion := compilerVersion
	defer func() { compilerVersion = originalVersion }()

	// Test with dev version - should not include version in header
	SetVersion("dev")
	header := GenerateWorkflowHeader("test.md", "gh-aw", "")

	if strings.Contains(header, "(dev)") {
		t.Error("Expected header to NOT include version for dev builds")
	}
	if !strings.Contains(header, "This file was automatically generated by gh-aw. DO NOT EDIT.") {
		t.Error("Expected header to contain disclaimer without version")
	}
}

func TestGenerateWorkflowHeader_VersionInReleaseBuild(t *testing.T) {
	// Save original state
	originalVersion := compilerVersion
	originalIsRelease := isReleaseBuild
	defer func() {
		compilerVersion = originalVersion
		isReleaseBuild = originalIsRelease
	}()

	// Test with release version - should include version in header when isRelease is true
	SetVersion("1.0.0")
	SetIsRelease(true)
	header := GenerateWorkflowHeader("test.md", "gh-aw", "")

	if !strings.Contains(header, "This file was automatically generated by gh-aw (1.0.0). DO NOT EDIT.") {
		t.Errorf("Expected header to contain disclaimer with version, got:\n%s", header)
	}
}

func TestGenerateWorkflowHeader_DirtyVersion(t *testing.T) {
	// Save original version
	originalVersion := compilerVersion
	defer func() { compilerVersion = originalVersion }()

	// Test with dirty version (git describe output) - should NOT include version
	// IsReleasedVersion excludes versions containing "dirty"
	SetVersion("c610c2a-dirty")
	header := GenerateWorkflowHeader("test.md", "gh-aw", "")

	if strings.Contains(header, "(c610c2a-dirty)") {
		t.Error("Expected header to NOT include version for dirty builds")
	}
	if !strings.Contains(header, "This file was automatically generated by gh-aw. DO NOT EDIT.") {
		t.Error("Expected header to contain disclaimer without version")
	}
}

func TestGenerateWorkflowHeader_GitHashVersion(t *testing.T) {
	// Save original version
	originalVersion := compilerVersion
	defer func() { compilerVersion = originalVersion }()

	// Test with git hash version - should NOT include version
	// IsReleasedVersion requires proper semver format
	SetVersion("c610c2a")
	header := GenerateWorkflowHeader("test.md", "gh-aw", "")

	if strings.Contains(header, "(c610c2a)") {
		t.Error("Expected header to NOT include version for git hash builds")
	}
	if !strings.Contains(header, "This file was automatically generated by gh-aw. DO NOT EDIT.") {
		t.Error("Expected header to contain disclaimer without version")
	}
}

func TestGenerateWorkflowHeader_EmptyVersion(t *testing.T) {
	// Save original version
	originalVersion := compilerVersion
	defer func() { compilerVersion = originalVersion }()

	// Test with empty version - should not include version in header
	SetVersion("")
	header := GenerateWorkflowHeader("test.md", "gh-aw", "")

	if strings.Contains(header, "()") {
		t.Error("Expected header to NOT include empty parentheses")
	}
	if !strings.Contains(header, "This file was automatically generated by gh-aw. DO NOT EDIT.") {
		t.Error("Expected header to contain disclaimer without version")
	}
}

func TestGenerateWorkflowHeader_NoGeneratedBy(t *testing.T) {
	// Save original version
	originalVersion := compilerVersion
	defer func() { compilerVersion = originalVersion }()

	// Test with empty generatedBy - should use default message
	SetVersion("1.0.0")
	header := GenerateWorkflowHeader("test.md", "", "")

	if !strings.Contains(header, "This file was automatically generated. DO NOT EDIT.") {
		t.Error("Expected header to contain default disclaimer")
	}
	// Should not include version when generatedBy is empty
	if strings.Contains(header, "(1.0.0)") {
		t.Error("Expected header to NOT include version when generatedBy is empty")
	}
}

func TestGenerateWorkflowHeader_WithReleaseFlag(t *testing.T) {
	// Save original state
	originalVersion := compilerVersion
	originalIsRelease := isReleaseBuild
	defer func() {
		compilerVersion = originalVersion
		isReleaseBuild = originalIsRelease
	}()

	tests := []struct {
		name              string
		version           string
		isRelease         bool
		shouldHaveVersion bool
		description       string
	}{
		{
			name:              "Release build with valid version",
			version:           "1.0.0",
			isRelease:         true,
			shouldHaveVersion: true,
			description:       "Release build should include version in header",
		},
		{
			name:              "Dev build with valid version",
			version:           "1.0.0",
			isRelease:         false,
			shouldHaveVersion: false,
			description:       "Non-release build should not include version",
		},
		{
			name:              "Dev build with dev version",
			version:           "dev",
			isRelease:         false,
			shouldHaveVersion: false,
			description:       "Non-release build with 'dev' version should not include version",
		},
		{
			name:              "Release build with dev version",
			version:           "dev",
			isRelease:         true,
			shouldHaveVersion: true,
			description:       "Release build should include version even if it says 'dev'",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			SetVersion(tt.version)
			SetIsRelease(tt.isRelease)
			header := GenerateWorkflowHeader("test.md", "gh-aw", "")

			hasVersion := strings.Contains(header, "("+tt.version+")")
			if hasVersion != tt.shouldHaveVersion {
				t.Errorf("Header version inclusion = %v, want %v\n%s\nHeader:\n%s",
					hasVersion, tt.shouldHaveVersion, tt.description, header)
			}
		})
	}
}
