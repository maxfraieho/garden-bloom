import { describe, it, expect, beforeEach, vi } from "vitest";

// Mock core global
const mockCore = {
  info: vi.fn(),
};
global.core = mockCore;

describe("ephemerals", () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe("formatExpirationDate", () => {
    it("should format date to human-readable string in UTC", async () => {
      const { formatExpirationDate } = await import("./ephemerals.cjs");
      const date = new Date("2026-01-25T15:54:08.894Z");
      const result = formatExpirationDate(date);
      expect(result).toMatch(/Jan 25, 2026/);
      // Note: formatExpirationDate returns format like "Jan 25, 2026, 3:54 PM"
      // UTC is added by createExpirationLine, not by formatExpirationDate itself
    });
  });

  describe("createExpirationLine", () => {
    it("should create expiration line with checkbox and date", async () => {
      const { createExpirationLine } = await import("./ephemerals.cjs");
      const date = new Date("2026-01-25T15:54:08.894Z");
      const result = createExpirationLine(date);

      expect(result).toContain("- [x] expires");
      expect(result).toContain("<!-- gh-aw-expires: 2026-01-25T15:54:08.894Z -->");
      expect(result).toContain("on");
      expect(result).toContain("UTC");
    });

    it("should include ISO format in XML comment", async () => {
      const { createExpirationLine } = await import("./ephemerals.cjs");
      const date = new Date("2026-01-25T15:54:08.894Z");
      const result = createExpirationLine(date);

      expect(result).toMatch(/<!-- gh-aw-expires: \d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z -->/);
    });
  });

  describe("extractExpirationDate", () => {
    it("should extract date from body with expiration marker", async () => {
      const { extractExpirationDate } = await import("./ephemerals.cjs");
      const body = "Some text\n> - [x] expires <!-- gh-aw-expires: 2026-01-25T15:54:08.894Z --> on Jan 25, 2026\nMore text";
      const result = extractExpirationDate(body);

      expect(result).toBeInstanceOf(Date);
      expect(result?.toISOString()).toBe("2026-01-25T15:54:08.894Z");
    });

    it("should extract date from body with blockquote prefix (new format)", async () => {
      const { extractExpirationDate } = await import("./ephemerals.cjs");
      const body = "> AI generated by Workflow\n>\n> - [x] expires <!-- gh-aw-expires: 2026-01-25T15:54:08.894Z --> on Jan 25, 2026, 3:54 PM UTC";
      const result = extractExpirationDate(body);

      expect(result).toBeInstanceOf(Date);
      expect(result?.toISOString()).toBe("2026-01-25T15:54:08.894Z");
    });

    it("should extract date from legacy format without HTML comment", async () => {
      const { extractExpirationDate } = await import("./ephemerals.cjs");
      const body = "> AI generated by Daily Team Status\n>\n> To add this workflow in your repository\n> - [x] expires  on Jan 20, 2026, 9:20 AM UTC";
      const result = extractExpirationDate(body);

      expect(result).toBeInstanceOf(Date);
      expect(result?.toISOString()).toBe("2026-01-20T09:20:00.000Z");
    });

    it("should extract date from actual issue #10667 format", async () => {
      const { extractExpirationDate } = await import("./ephemerals.cjs");
      const body = `> AI generated by Daily Team Status
>
> To add this workflow in your repository, run \`gh aw add githubnext/agentics/workflows/daily-team-status.md@d3422bf940923ef1d43db5559652b8e1e71869f3\`. See usage guide.
> - [x] expires  on Jan 20, 2026, 9:20 AM UTC
`;
      const result = extractExpirationDate(body);

      expect(result).toBeInstanceOf(Date);
      expect(result?.toISOString()).toBe("2026-01-20T09:20:00.000Z");
    });

    it("should return null when no expiration marker found", async () => {
      const { extractExpirationDate } = await import("./ephemerals.cjs");
      const body = "Some text without expiration marker";
      const result = extractExpirationDate(body);

      expect(result).toBeNull();
    });

    it("should return null for invalid date", async () => {
      const { extractExpirationDate } = await import("./ephemerals.cjs");
      const body = "> - [x] expires <!-- gh-aw-expires: invalid-date --> on Jan 25, 2026";
      const result = extractExpirationDate(body);

      expect(result).toBeNull();
    });

    it("should return null for invalid legacy date", async () => {
      const { extractExpirationDate } = await import("./ephemerals.cjs");
      const body = "> - [x] expires  on Not a valid date string UTC";
      const result = extractExpirationDate(body);

      expect(result).toBeNull();
    });

    it("should handle standard expiration marker format", async () => {
      const { extractExpirationDate } = await import("./ephemerals.cjs");
      const body = "Some text\n> - [x] expires <!-- gh-aw-expires: 2026-01-25T15:54:08.894Z --> on Jan 25, 2026\nMore text";
      const result = extractExpirationDate(body);

      expect(result).toBeInstanceOf(Date);
      expect(result?.toISOString()).toBe("2026-01-25T15:54:08.894Z");
    });

    it("should prefer new format over legacy when both present", async () => {
      const { extractExpirationDate } = await import("./ephemerals.cjs");
      // This would be malformed, but tests the priority
      const body = "> - [x] expires <!-- gh-aw-expires: 2026-01-25T15:54:08.894Z --> on Jan 20, 2026, 9:20 AM UTC";
      const result = extractExpirationDate(body);

      expect(result).toBeInstanceOf(Date);
      // Should use ISO date from HTML comment, not the human-readable date
      expect(result?.toISOString()).toBe("2026-01-25T15:54:08.894Z");
    });
  });

  describe("generateFooterWithExpiration", () => {
    it("should generate footer without expiration when expiresHours is 0", async () => {
      const { generateFooterWithExpiration } = await import("./ephemerals.cjs");
      const result = generateFooterWithExpiration({
        footerText: "> AI generated by [Workflow](url)",
        expiresHours: 0,
      });

      expect(result).toBe("> AI generated by [Workflow](url)");
      expect(mockCore.info).not.toHaveBeenCalled();
    });

    it("should generate footer without expiration when expiresHours is undefined", async () => {
      const { generateFooterWithExpiration } = await import("./ephemerals.cjs");
      const result = generateFooterWithExpiration({
        footerText: "> AI generated by [Workflow](url)",
      });

      expect(result).toBe("> AI generated by [Workflow](url)");
      expect(mockCore.info).not.toHaveBeenCalled();
    });

    it("should add expiration line in quoted section", async () => {
      const { generateFooterWithExpiration } = await import("./ephemerals.cjs");
      const result = generateFooterWithExpiration({
        footerText: "> AI generated by [Workflow](url)",
        expiresHours: 168,
        entityType: "Issue",
      });

      expect(result).toContain("> AI generated by [Workflow](url)");
      expect(result).toContain("- [x] expires");
      expect(result).toContain("<!-- gh-aw-expires:");
      expect(mockCore.info).toHaveBeenCalledWith(expect.stringContaining("Issue will expire on"));
    });

    it("should add suffix after expiration", async () => {
      const { generateFooterWithExpiration } = await import("./ephemerals.cjs");
      const result = generateFooterWithExpiration({
        footerText: "> AI generated by [Workflow](url)",
        expiresHours: 168,
        suffix: "\n\n<!-- gh-aw-marker: test -->",
      });

      expect(result).toContain("- [x] expires");
      expect(result).toContain("<!-- gh-aw-marker: test -->");
      expect(result.indexOf("expires")).toBeLessThan(result.indexOf("gh-aw-marker"));
    });

    it("should add suffix without expiration", async () => {
      const { generateFooterWithExpiration } = await import("./ephemerals.cjs");
      const result = generateFooterWithExpiration({
        footerText: "> AI generated by [Workflow](url)",
        expiresHours: 0,
        suffix: "\n\n<!-- gh-aw-marker: test -->",
      });

      expect(result).toBe("> AI generated by [Workflow](url)\n\n<!-- gh-aw-marker: test -->");
      expect(result).not.toContain("expires");
    });

    it("should log expiration info when entityType is provided", async () => {
      const { generateFooterWithExpiration } = await import("./ephemerals.cjs");
      generateFooterWithExpiration({
        footerText: "> AI generated",
        expiresHours: 24,
        entityType: "Discussion",
      });

      expect(mockCore.info).toHaveBeenCalledWith(expect.stringContaining("Discussion will expire on"));
      expect(mockCore.info).toHaveBeenCalledWith(expect.stringContaining("24 hours"));
    });

    it("should not log when entityType is not provided", async () => {
      const { generateFooterWithExpiration } = await import("./ephemerals.cjs");
      generateFooterWithExpiration({
        footerText: "> AI generated",
        expiresHours: 24,
      });

      expect(mockCore.info).not.toHaveBeenCalled();
    });
  });

  describe("addExpirationToFooter", () => {
    it("should return footer unchanged when expiresHours is 0", async () => {
      const { addExpirationToFooter } = await import("./ephemerals.cjs");
      const footer = "> AI generated by [Workflow](url)";
      const result = addExpirationToFooter(footer, 0);

      expect(result).toBe(footer);
      expect(mockCore.info).not.toHaveBeenCalled();
    });

    it("should return footer unchanged when expiresHours is undefined", async () => {
      const { addExpirationToFooter } = await import("./ephemerals.cjs");
      const footer = "> AI generated by [Workflow](url)";
      const result = addExpirationToFooter(footer, undefined);

      expect(result).toBe(footer);
    });

    it("should add expiration to simple footer without XML marker", async () => {
      const { addExpirationToFooter } = await import("./ephemerals.cjs");
      const footer = "\n\n> AI generated by [Workflow](url)";
      const result = addExpirationToFooter(footer, 168, "Issue");

      expect(result).toContain("> AI generated by [Workflow](url)");
      expect(result).toContain("- [x] expires");
      expect(mockCore.info).toHaveBeenCalledWith(expect.stringContaining("Issue will expire on"));
    });

    it("should insert expiration before XML marker", async () => {
      const { addExpirationToFooter } = await import("./ephemerals.cjs");
      const footer = "\n\n> AI generated by [Workflow](url)\n\n<!-- gh-aw-agentic-workflow: test, run: url -->\n";
      const result = addExpirationToFooter(footer, 168);

      expect(result).toContain("- [x] expires");
      expect(result).toContain("<!-- gh-aw-agentic-workflow: test");
      // Expiration should come before XML marker
      const expiresIndex = result.indexOf("expires");
      const xmlIndex = result.indexOf("<!-- gh-aw-agentic-workflow");
      expect(expiresIndex).toBeLessThan(xmlIndex);
    });

    it("should preserve XML marker at the end", async () => {
      const { addExpirationToFooter } = await import("./ephemerals.cjs");
      const footer = "\n\n> AI generated\n\n<!-- gh-aw-marker -->\n";
      const result = addExpirationToFooter(footer, 24);

      expect(result).toMatch(/> - \[x\] expires.*\n\n<!-- gh-aw-marker -->\n$/);
    });

    it("should log expiration info when entityType is provided", async () => {
      const { addExpirationToFooter } = await import("./ephemerals.cjs");
      const footer = "> AI generated";
      addExpirationToFooter(footer, 48, "Pull Request");

      expect(mockCore.info).toHaveBeenCalledWith(expect.stringContaining("Pull Request will expire on"));
      expect(mockCore.info).toHaveBeenCalledWith(expect.stringContaining("48 hours"));
    });

    it("should handle footer with multiline XML marker", async () => {
      const { addExpirationToFooter } = await import("./ephemerals.cjs");
      const footer = "\n\n> Footer\n\n<!-- gh-aw-workflow: test,\n  run: url,\n  model: gpt-4 -->";
      const result = addExpirationToFooter(footer, 24);

      expect(result).toContain("- [x] expires");
      expect(result).toContain("<!-- gh-aw-workflow: test");
      expect(result).toContain("model: gpt-4 -->");
    });
  });

  describe("EXPIRATION_PATTERN", () => {
    it("should be exported", async () => {
      const { EXPIRATION_PATTERN } = await import("./ephemerals.cjs");
      expect(EXPIRATION_PATTERN).toBeInstanceOf(RegExp);
    });

    it("should NOT match standard expiration line without blockquote", async () => {
      const { EXPIRATION_PATTERN } = await import("./ephemerals.cjs");
      const line = "- [x] expires <!-- gh-aw-expires: 2026-01-25T15:54:08.894Z --> on Jan 25, 2026";
      // This should NOT match because the pattern requires blockquote prefix
      expect(EXPIRATION_PATTERN.test(line)).toBe(false);
    });

    it("should match expiration line with blockquote prefix", async () => {
      const { EXPIRATION_PATTERN } = await import("./ephemerals.cjs");
      const line = "> - [x] expires <!-- gh-aw-expires: 2026-01-25T15:54:08.894Z --> on Jan 25, 2026";
      expect(EXPIRATION_PATTERN.test(line)).toBe(true);
    });

    it("should handle some whitespace variations", async () => {
      const { EXPIRATION_PATTERN } = await import("./ephemerals.cjs");
      const line = ">  -  [x]  expires  <!-- gh-aw-expires: 2026-01-25T15:54:08.894Z -->";
      expect(EXPIRATION_PATTERN.test(line)).toBe(true);
    });
  });

  describe("LEGACY_EXPIRATION_PATTERN", () => {
    it("should be exported", async () => {
      const { LEGACY_EXPIRATION_PATTERN } = await import("./ephemerals.cjs");
      expect(LEGACY_EXPIRATION_PATTERN).toBeInstanceOf(RegExp);
    });

    it("should match legacy format without HTML comment", async () => {
      const { LEGACY_EXPIRATION_PATTERN } = await import("./ephemerals.cjs");
      const line = "> - [x] expires  on Jan 20, 2026, 9:20 AM UTC";
      expect(LEGACY_EXPIRATION_PATTERN.test(line)).toBe(true);
    });

    it("should match legacy format with minimal whitespace", async () => {
      const { LEGACY_EXPIRATION_PATTERN } = await import("./ephemerals.cjs");
      const line = "> - [x] expires on Jan 20, 2026, 9:20 AM UTC";
      expect(LEGACY_EXPIRATION_PATTERN.test(line)).toBe(true);
    });

    it("should NOT match new format with HTML comment", async () => {
      const { LEGACY_EXPIRATION_PATTERN } = await import("./ephemerals.cjs");
      const line = "> - [x] expires <!-- gh-aw-expires: 2026-01-25T15:54:08.894Z --> on Jan 25, 2026 UTC";
      expect(LEGACY_EXPIRATION_PATTERN.test(line)).toBe(false);
    });

    it("should NOT match without UTC suffix", async () => {
      const { LEGACY_EXPIRATION_PATTERN } = await import("./ephemerals.cjs");
      const line = "> - [x] expires on Jan 20, 2026, 9:20 AM";
      expect(LEGACY_EXPIRATION_PATTERN.test(line)).toBe(false);
    });
  });
});
