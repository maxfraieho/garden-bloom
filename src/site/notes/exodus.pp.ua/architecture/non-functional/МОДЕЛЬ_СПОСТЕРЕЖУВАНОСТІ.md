---
{"tags":["domain:arch","status:canonical","format:spec","feature:execution"],"created":"2026-02-22","updated":"2026-02-22","tier":1,"title":"МОДЕЛЬ СПОСТЕРЕЖУВАНОСТІ","dg-publish":true,"dg-metatags":null,"dg-home":null,"permalink":"/exodus.pp.ua/architecture/non-functional/МОДЕЛЬ_СПОСТЕРЕЖУВАНОСТІ/","dgPassFrontmatter":true,"noteIcon":""}
---


# МОДЕЛЬ_СПОСТЕРЕЖУВАНОСТІ

> Створено: 2026-02-22
> Автор: Головний архітектор системи
> Статус: Канонічна специфікація
> Мова: Українська (канонічна)

---

## КОНТЕКСТ

Garden Bloom є асинхронною системою: агенти виконуються у background, proposals очікують на approval, runs можуть тривати хвилини. Owner повинен мати **повну видимість стану системи** без необхідності читати логи або дивитись у MinIO напряму.

Спостережуваність — не інструментація заради інструментації. Це **знання про систему, що потрібно для прийняття рішень**: чи потрібно щось робити зараз?

---

## ПРОБЛЕМА

Без explicit observability model:
- Owner не знає, що агент "застряг"
- Неможливо знайти причину failure без ручного дослідження MinIO
- Відсутній distributed trace для debugging multi-step run

---

## РІШЕННЯ

### Рівні спостережуваності

**Рівень 1 — Canonical state (завжди доступний)**

MinIO є основним джерелом стану. Все observable через:
```
agents/{slug}/runs/{runId}/status.json     ← поточний стан run
agents/{slug}/runs/{runId}/steps/*.json    ← детальний step output
agents/{slug}/proposals/*.json             ← proposals та їх стан
audit/runs/{yyyy-mm}/{runId}.json          ← cross-agent audit trail
```

**Рівень 2 — Frontend projection (для Owner)**

Frontend polling Worker API → відображає:
- Agent dashboard: список агентів + їх last run status
- Run timeline: history runs з duration та outcome
- Proposal inbox: pending proposals з preview
- System health: indicators компонентів

**Рівень 3 — Structured logging (для debugging)**

Кожен компонент пише structured logs:

| Component | Log format | Storage |
|-----------|-----------|---------|
| Cloudflare Worker | JSON structured | Cloudflare Logpush → MinIO `/audit/worker/` |
| Orchestration Layer | JSON structured | Hatchet dashboard + MinIO `/audit/runs/` |
| Mastra | JSON structured | stdout → Agent Service logs |
| FastAPI | JSON structured | stdout → container logs |

### Audit log schema

**[КАНОНІЧНИЙ ФОРМАТ]** Кожен event в `/audit/` має структуру:

```json
{
  "event_id": "evt_2026-02-22_abc123",
  "timestamp": "2026-02-22T10:00:00.000Z",
  "type": "run.started | run.completed | run.failed | proposal.created | proposal.approved | proposal.applied | proposal.rejected | agent.activated | agent.error",
  "actor": {
    "type": "agent | owner | system | orchestration",
    "identity": "agent:archivist-violin | owner | hatchet"
  },
  "resource": {
    "type": "run | proposal | agent",
    "id": "run_2026-02-22_abc123"
  },
  "metadata": {
    "duration_ms": 45000,
    "agent_slug": "archivist-violin",
    "run_id": "run_2026-02-22_abc123"
  }
}
```

**[ПРИНЦИП]** Audit log є **append-only**. Записує Worker. Ніхто не видаляє записи (лише архівує по місяцях).

### Метрики (key indicators)

| Метрика | Threshold для alert | Де збирається |
|---------|---------------------|---------------|
| Run failure rate | > 30% за останні 10 runs | MinIO audit log |
| P95 run latency | > 300 сек | MinIO run status |
| Pending proposals age | > 48 годин без дії | MinIO proposals/pending/ |
| Consecutive agent failures | ≥ 3 | MinIO agent status |
| NLM tool error rate | > 50% за 1 годину | Worker logs |
| MinIO storage usage | > 80% capacity | MinIO metrics |

### Alerting

**MVP** (версія 1): Polling-based alerts від Frontend.

```
Frontend → Worker GET /system/health
Response:
{
  "status": "healthy | degraded | critical",
  "components": {
    "minio": "healthy | degraded | unavailable",
    "orchestration": "healthy | degraded | unavailable",
    "nlm_proxy": "healthy | degraded | unavailable"
  },
  "pending_proposals_count": 5,
  "failed_agents_count": 0,
  "last_run_status": "completed | failed"
}
```

**V2**: Push notifications (SSE або Telegram) для критичних подій.

### Run introspection

Owner може повністю відстежити будь-який run:

```
GET /runs/{runId}/trace → returns:
{
  "run_id": "run_2026-02-22_abc123",
  "agent": "archivist-violin",
  "status": "completed",
  "duration_ms": 45000,
  "steps": [
    { "id": 1, "name": "context_load", "status": "completed", "duration_ms": 3000 },
    { "id": 2, "name": "agent_execute", "status": "completed", "duration_ms": 38000 },
    { "id": 3, "name": "proposals_write", "status": "completed", "duration_ms": 1000 },
    { "id": 4, "name": "finalize", "status": "completed", "duration_ms": 500 }
  ],
  "proposals_created": ["prop_abc123"],
  "memory_updates": 1
}
```

---

## ІНВАРІАНТИ

**OBS-INV-001:** Кожен run має canonical trace у MinIO (`runs/{id}/steps/*.json`). Frontend не є авторитетним джерелом run state.

**OBS-INV-002:** Audit log є append-only та immutable. Зміна або видалення audit records є архітектурним порушенням.

**OBS-INV-003:** Frontend health dashboard відображає **стан canonical storage**, а не стан runtime components (runtime може бути down, але MinIO містить повну картину).

---

## ЗВ'ЯЗКИ

**Цей документ залежить від:**
- [[exodus.pp.ua/architecture/foundation/АРХІТЕКТУРНИЙ_КОРІНЬ\|АРХІТЕКТУРНИЙ_КОРІНЬ]] — A1 (canonical storage), A5 (gateway as single entry)
- [[exodus.pp.ua/architecture/core/КАНОНІЧНА_МОДЕЛЬ_АВТОРИТЕТУ_СХОВИЩА\|КАНОНІЧНА_МОДЕЛЬ_АВТОРИТЕТУ_СХОВИЩА]] — audit write paths
- [[exodus.pp.ua/architecture/core/КАНОНІЧНИЙ_ЦИКЛ_ЗАПУСКУ\|КАНОНІЧНИЙ_ЦИКЛ_ЗАПУСКУ]] — run states та transitions
- [[exodus.pp.ua/architecture/core/INBOX_ТА_PROPOSAL_АРХІТЕКТУРА\|INBOX_ТА_PROPOSAL_АРХІТЕКТУРА]] — proposal lifecycle events

**Цей документ впливає на:**
- [[exodus.pp.ua/architecture/non-functional/БЕЗПЕКА_СИСТЕМИ\|БЕЗПЕКА_СИСТЕМИ]] — audit log is security control
- [[exodus.pp.ua/backend/КОНТРАКТИ_API_V1\|КОНТРАКТИ_API_V1]] — /system/health та /runs/{id}/trace endpoints

---

*Цей документ визначає observability model для Garden Bloom: canonical storage як primary source of truth, Frontend як projection layer.*
