---
{"tags":["domain:drakon","status:draft","format:guide","feature:orchestration"],"created":"2026-02-21","updated":"2026-02-21","tier":2,"title":"СТРАТЕГІЯ ІНТЕГРАЦІЇ","dg-publish":true,"dg-metatags":null,"dg-home":null,"permalink":"/exodus.pp.ua/drakon/СТРАТЕГІЯ_ІНТЕГРАЦІЇ/","dgPassFrontmatter":true,"noteIcon":""}
---


# INTEGRATION_STRATEGY_UA — Архітектурні рішення інтеграції DRAKON у Garden Bloom

**Дата:** 2026-02-07
**Базується на:** PROJECT_ANALYSIS_UA, CLAUDE_SKILLS_SELECTION_UA, DRAKONWIDGET_RESEARCH_UA

---

## 1. Архітектурне рішення: Direct Integration

### Обране рішення
**Direct Integration** з lazy loading, React wrapper та CSS scoping.

### Обґрунтування
- Garden Bloom — SPA без SSR → client-only mount не є проблемою
- Проєкт використовує Vite → підтримує dynamic imports та code splitting
- shadcn-ui + Tailwind → потрібна CSS ізоляція, але не повна (shadow DOM overkill)
- 1 віджет → мікрофронтенд — overengineering
- iframe → не дозволяє стилізацію та accessibility

---

## 2. Де зберігати діаграми

### Рішення: JSON-файли поруч з markdown нотатками

```
src/site/notes/{folder}/{note-slug}/
├── index.md                    # Текст нотатки
└── diagrams/
    ├── diagram-1.drakon.json   # DRAKON діаграма
    └── diagram-2.drakon.json
```

### Альтернативний варіант: embed у markdown frontmatter

```markdown
---
title: "Алгоритм обробки"
diagrams:
  - id: "process-flow"
    file: "./diagrams/process-flow.drakon.json"
---

Опис алгоритму...

:::drakon id="process-flow":::

Пояснення після діаграми.
```

### Обґрунтування
- **Окремі файли** — простіший git diff, менші конфлікти merge
- **JSON формат** — нативний формат drakonwidget (`exportJson()` / `setDiagram()`)
- **Collocated** з нотаткою — зрозуміла зв'язка контент ↔ діаграма
- **Frontmatter reference** — декларативний зв'язок через metadata

### Формат зберігання діаграми

```typescript
// src/lib/drakon/types.ts
interface StoredDrakonDiagram {
  version: '1.0';
  id: string;
  name: string;
  createdAt: string;     // ISO 8601
  updatedAt: string;     // ISO 8601
  access: 'read' | 'write';
  diagram: {
    items: Record<string, DrakonItem>;
    params?: string;
    style?: string;
  };
}
```

---

## 3. Формат вставки у Markdown

### Рішення: Custom directive `:::drakon`

```markdown
Опис перед діаграмою.

:::drakon id="process-flow" height="400" mode="view":::

Пояснення після діаграми.
```

### Параметри директиви

| Параметр | Тип | Default | Опис |
|----------|-----|---------|------|
| `id` | string | required | ID діаграми (filename без .drakon.json) |
| `height` | number | 400 | Висота контейнера в px |
| `mode` | 'view' \| 'edit' | 'view' | Режим відображення |
| `theme` | string | 'auto' | Тема (auto = відповідно до dark/light mode) |
| `zoom` | number | 10000 | Початковий масштаб (100% = 10000) |

### Альтернативний синтаксис (code block)

```markdown
```drakon
id: process-flow
height: 400
mode: view
```​
```

### Обґрунтування вибору `:::drakon`
- Відповідає existing wikilink pattern `[[...]]` та markdown extensions
- Не конфліктує з standard markdown
- Простий для парсингу (regex)
- Знайомий синтаксис (схожий на markdown containers)

---

## 4. Підхід до рендерингу

### Рішення: Розширення react-markdown через custom component

#### 4.1. Remark plugin для парсингу `:::drakon`

```typescript
// src/lib/drakon/remarkDrakon.ts
// Remark plugin that transforms :::drakon::: into custom AST nodes
```

#### 4.2. React-markdown custom component

```typescript
// У NoteRenderer.tsx додати:
const components: Components = {
  // ... existing components (p, li, strong, etc.)

  // DRAKON diagram block
  'drakon-diagram': ({ id, height, mode, theme, zoom }) => (
    <DrakonDiagramBlock
      diagramId={id}
      height={height}
      mode={mode}
      theme={theme}
      zoom={zoom}
    />
  ),
};
```

#### 4.3. Компонент DrakonDiagramBlock

```
DrakonDiagramBlock (markdown block)
  └── Suspense + lazy loading
       └── DrakonViewer (read-only)
            або
            DrakonEditor (editable)
                 └── drakonwidget.js (vanilla JS)
```

#### 4.4. Lifecycle management

```
Mount:
1. DrakonDiagramBlock renders placeholder (Skeleton)
2. Lazy import drakonwidget.js
3. Create instance: createDrakonWidget()
4. Render into container ref: drakon.render(w, h, config)
5. Load diagram: drakon.setDiagram(id, data, sender)

Resize:
1. ResizeObserver на контейнері
2. Debounce 200ms
3. drakon.render(newW, newH, config)
4. drakon.redraw()

Unmount:
1. editSender.stop()
2. Remove DOM element
3. Nullify references
4. Remove ResizeObserver
```

---

## 5. Стратегія ізоляції CSS

### Рішення: Scoped container з CSS reset

```css
/* src/styles/drakon-scope.css */
.drakon-container {
  /* Ізоляція від Tailwind */
  isolation: isolate;
  position: relative;

  /* Reset inherited styles */
  font: 14px Arial;
  color: black;
  line-height: 1.3;

  /* Contain layout */
  contain: layout style;
}

/* Override Tailwind resets inside container */
.drakon-container * {
  box-sizing: content-box; /* drakonwidget expects this */
}

.drakon-container canvas {
  display: block;
}
```

### Theme bridging (dark/light mode)

```typescript
// src/lib/drakon/themeAdapter.ts
export function gardenThemeToDrakon(isDark: boolean): DrakonTheme {
  return isDark ? {
    background: '#1e293b',      // slate-800
    iconBack: '#334155',         // slate-700
    iconBorder: '#64748b',       // slate-500
    color: '#f1f5f9',            // slate-100
    lines: '#94a3b8',            // slate-400
    shadowColor: 'rgba(0,0,0,0.4)',
  } : {
    background: '#f1f5f9',       // slate-100
    iconBack: 'white',
    iconBorder: '#94a3b8',       // slate-400
    color: '#1e293b',            // slate-800
    lines: '#475569',            // slate-600
    shadowColor: 'rgba(0,0,0,0.15)',
  };
}
```

---

## 6. Файлова структура нових файлів

```
src/
├── components/
│   └── garden/
│       ├── DrakonDiagramBlock.tsx    # Markdown integration block
│       ├── DrakonViewer.tsx          # Read-only viewer
│       └── DrakonEditor.tsx          # Editable viewer (owner only)
├── hooks/
│   └── useDrakonDiagram.ts          # Hook для load/save діаграм
├── lib/
│   └── drakon/
│       ├── adapter.ts               # Завантаження та ініціалізація
│       ├── types.ts                  # TypeScript інтерфейси
│       ├── themeAdapter.ts           # Тема: garden → drakon
│       ├── remarkDrakon.ts           # Remark plugin
│       └── diagramStore.ts           # CRUD для діаграм
├── styles/
│   └── drakon-scope.css              # CSS ізоляція
└── types/
    └── drakonwidget.d.ts             # TypeScript declarations

public/
└── libs/
    └── drakonwidget.js               # Vendor copy
```

---

## 7. Інтеграція з Access Zones

### Поведінка в різних контекстах

| Контекст | Режим DRAKON | Можливості |
|----------|-------------|------------|
| Owner authenticated | edit (якщо `mode="edit"`) | Повне редагування, export, save |
| Owner authenticated | view | Перегляд, zoom, навігація |
| Zone guest (web) | view only | Перегляд, zoom (без edit) |
| Zone guest (MCP) | JSON only | Тільки JSON дані діаграми |
| Not authenticated | hidden | Діаграма не рендериться |

### Реалізація

```typescript
// В DrakonDiagramBlock.tsx
const { isAuthenticated } = useOwnerAuth();
const effectiveMode = isAuthenticated ? mode : 'view';
const config = {
  ...baseConfig,
  canSelect: effectiveMode === 'edit',
};
```

---

## 8. Інтеграція з i18n

### Нові ключі перекладу

```typescript
// Додати в src/lib/i18n/types.ts → Translations
drakon: {
  loading: string;          // "Завантаження діаграми..."
  loadError: string;        // "Помилка завантаження діаграми"
  notFound: string;         // "Діаграму не знайдено"
  editMode: string;         // "Режим редагування"
  viewMode: string;         // "Режим перегляду"
  exportPng: string;        // "Експорт PNG"
  exportSvg: string;        // "Експорт SVG"
  exportJson: string;       // "Експорт JSON"
  zoomIn: string;           // "Збільшити"
  zoomOut: string;          // "Зменшити"
  zoomReset: string;        // "Скинути масштаб"
  saved: string;            // "Діаграму збережено"
  saveError: string;        // "Помилка збереження"
};
```

### translate callback для drakonwidget

```typescript
// Переклад контекстного меню drakonwidget
function createTranslateFunction(t: Translations): (text: string) => string {
  const map: Record<string, string> = {
    'Copy': t.common.copied ? 'Копіювати' : 'Copy',
    'Cut': 'Вирізати',
    'Paste': 'Вставити',
    'Delete': 'Видалити',
    // ... всі 30+ рядків з README
  };
  return (text: string) => map[text] || text;
}
```

---

## 9. Performance стратегія

1. **Lazy loading** — `React.lazy()` для DrakonViewer/DrakonEditor
2. **Dynamic script** — drakonwidget.js завантажується тільки коли потрібна діаграма
3. **Intersection Observer** — рендерити тільки видимі діаграми
4. **Debounced resize** — ResizeObserver з 200ms debounce
5. **Diagram caching** — кешування завантажених діаграм через React Query
6. **Code splitting** — окремий chunk для всього drakon-related коду

### Bundle impact

| Компонент | Розмір | Стратегія |
|-----------|--------|-----------|
| drakonwidget.js | ~1.4 MB | Lazy script loading |
| React adapter code | ~5-10 KB | Tree-shakeable |
| Types (.d.ts) | 0 KB runtime | Compile-time only |
| CSS | ~1 KB | Inline або imported |

---

## 10. Security considerations

1. **XSS через diagram content** — sanitize content перед рендерингом у DOM mode
2. **No eval()** — drakonwidget не використовує eval, але перевірити
3. **JSON parsing** — wrap у try/catch при завантаженні діаграм
4. **CSP** — drakonwidget.js має бути в allowed scripts
5. **Access control** — діаграми за authentication gate

---

## 11. Висновок

Обрана стратегія **Direct Integration** з наступними ключовими рішеннями:

| Рішення | Вибір |
|---------|-------|
| Інтеграційний підхід | Direct Integration + lazy loading |
| Зберігання діаграм | JSON файли collocated з markdown |
| Markdown синтаксис | `:::drakon id="..." height="...":::` |
| Рендеринг | react-markdown custom component + remark plugin |
| CSS ізоляція | Scoped container + isolation: isolate |
| TypeScript | Custom .d.ts + adapter layer |
| Theme | Auto-bridging garden dark/light → drakon theme |
| Performance | Lazy load + Intersection Observer + code splitting |
