---
{"tags":["domain:drakon","status:canonical","format:research","feature:logic"],"created":"2026-02-21","updated":"2026-02-21","tier":2,"title":"АНАЛІЗ_ПРОЕКТУ","dg-publish":true,"dg-metatags":null,"dg-home":null,"permalink":"/exodus.pp.ua/drakon/АНАЛІЗ_ПРОЕКТУ/","dgPassFrontmatter":true,"noteIcon":""}
---

# Аналіз проекту: DRAKON у контексті Garden Bloom

> Статус: Актуальний аналіз
> Мова: Українська (канонічна)

---

## 0. Контекст: що таке Garden Bloom насправді

**Garden Bloom** — це execution platform для автономних AI-агентів із вбудованим human-in-the-loop контролем. Це **не** digital garden для публікації нотаток. Markdown-файли та папки є одночасно визначеннями агентів, їхньою пам'яттю та поведінкою.

Ключова ідея: агент **пропонує** зміни → Owner **вирішує**. Кожна мутація — через Proposal lifecycle. Кожен крок — в аудит-лозі.

Архітектура детально визначена в [[exodus.pp.ua/architecture/АРХІТЕКТУРНИЙ_КОРІНЬ\|АРХІТЕКТУРНИЙ_КОРІНЬ]] та [[exodus.pp.ua/architecture/КАНОНІЧНА_АРХІТЕКТУРА_ВИКОНАННЯ\|КАНОНІЧНА_АРХІТЕКТУРА_ВИКОНАННЯ]].

---

## 1. Роль DRAKON у системі

DRAKON є **канонічним форматом визначення логіки агентів** — не інструментом для рендерингу діаграм у нотатках.

### 1.1 Дві різні проблеми

| Старий (хибний) фрейм | Правильний фрейм |
|----------------------|------------------|
| "Як вставити DRAKON-діаграму у markdown-нотатку?" | "Як людина визначає поведінку агента через DRAKON?" |
| Проблема рендерингу | Проблема дизайну агентної логіки |
| Frontend UI challenge | Архітектурна роль у pipeline |

### 1.2 Місце DRAKON у ланцюгу трансформацій

```
[Людина у DRAKON Editor]
        │
        ▼  зберегти .drakon.json
[MinIO: agents/<slug>/drakon/]
        │
        ▼  drakongen (автоматично)
[pseudocode.md] ← behavioral contract
        │
        ▼  agentExporter() (автоматично)
[_agent.md] ← фронтматтер + pseudocode body
        │
        ▼  Hatchet завантажує per run
[Mastra Runtime] ← stateless interpreter
        │
        ▼
[Proposal → Inbox → Owner approval]
```

Деталі трансформації: [[exodus.pp.ua/architecture/DRAKON_ІНТЕГРАЦІЯ_ТА_МОДЕЛЬ_ВИКОНАННЯ_АГЕНТА\|DRAKON_ІНТЕГРАЦІЯ_ТА_МОДЕЛЬ_ВИКОНАННЯ_АГЕНТА]]

### 1.3 Що DRAKON-файли зберігають

```
garden-agents/agents/<slug>/
├── drakon/
│   ├── main-flow.drakon.json       ← ДЖЕРЕЛО ІСТИНИ логіки агента
│   └── error-handling.drakon.json  ← підпотоки (опціонально)
├── pseudocode.md                   ← згенеровано з діаграм
└── _agent.md                       ← frontmatter + pseudocode body
```

**[ІНВАРІАНТ]** `.drakon.json` — авторитетне джерело. Якщо є розбіжність між діаграмою і pseudocode — pseudocode перегенеровується. Ручне редагування `_agent.md.body` без оновлення діаграми — порушення контракту.

---

## 2. Два контексти DRAKON у Frontend

Frontend (React SPA, створюваний Lovable) стосується DRAKON у **двох різних контекстах**:

### 2.1 Контекст А: DRAKON Editor (design-time)

Owner хоче **редагувати логіку агента** — будувати та змінювати діаграми.

```
Owner → Frontend DRAKON Editor → [Save] → Worker → MinIO
                                          → drakongen (Worker)
                                          → agentExporter() (Worker)
```

Потрібно:
- Embed `drakonwidget.js` у React як editor-компонент
- Зберігання: `PUT /agents/<slug>/drakon/<file>.drakon.json` через Worker
- Тригер регенерації: Worker запускає `drakongen` → зберігає `pseudocode.md` → запускає `agentExporter()` → зберігає `_agent.md`

### 2.2 Контекст Б: DRAKON Viewer (read-only)

Owner хоче **переглянути поточну логіку агента** — бачити що агент виконує.

```
Owner → Frontend DRAKON Viewer → [Load] ← Worker ← MinIO
```

Потрібно:
- Embed `drakonwidget.js` у React як read-only viewer
- Завантаження: `GET /agents/<slug>/drakon/<file>.drakon.json` через Worker

> **Примітка:** Вставка DRAKON-діаграм у Digital Garden нотатки (`src/site/notes/`) — можлива як **третій контекст** (публікація), але не є пріоритетом і не пов'язана з визначенням агентної логіки.

---

## 3. Технічна реалізація Frontend

### 3.1 Поточний стек

| Категорія | Технологія | Версія |
|-----------|-----------|--------|
| Frontend Framework | React | 18.3.1 |
| Build Tool | Vite | 5.4.19 |
| Мова | TypeScript | 5.8.3 |
| CSS Framework | Tailwind CSS | 3.4.17 |
| UI бібліотека | shadcn-ui (Radix UI) | — |
| State Management | TanStack Query | 5.83.0 |
| Routing | React Router DOM | 6.30.1 |
| Markdown | react-markdown + remark-gfm | — |

### 3.2 Поточна роль Frontend

Frontend є **projection layer** системи (Аксіома A6):
- Відображає canonical state через Worker API
- Ініціює дії Owner (approve/reject proposals, trigger agent runs)
- Не має write authority — все через Worker

Ключові компоненти Owner UI:
- `AccessGuard.tsx` — auth gate
- `OwnerAuthProvider` — master password auth
- `components/garden/` — projection UI
- `components/zones/` — access zone management

### 3.3 Що відсутнє для DRAKON

| Компонент | Статус | Примітка |
|-----------|--------|----------|
| DRAKON Editor сторінка | ❌ Немає | `/agents/<slug>/edit-logic` |
| DRAKON Viewer компонент | ❌ Немає | read-only embed |
| `drakonwidget.js` у проекті | ❌ Немає | потрібен у `public/libs/` |
| TypeScript типи для drakonwidget | ❌ Немає | потрібен `.d.ts` |
| Worker endpoint для drakon/ | ❌ Немає | `GET/PUT /agents/:slug/drakon/:file` |
| `drakongen` реалізація | ❌ Немає | трансформатор JSON → pseudocode.md |
| `agentExporter()` | ❌ Немає | збирач `_agent.md` |

---

## 4. DrakonWidget: технічні характеристики

**Бібліотека:** `drakonwidget` (Stepan Mitkin), форк: `maxfraieho/drakonwidget`
**Ліцензія:** Unlicense

### 4.1 Критичні обмеження

| Характеристика | Значення | Вплив |
|---------------|---------|-------|
| Формат модуля | **IIFE** (не ESM/CJS/UMD) | Не можна `import` напряму; потрібен `<script>` або dynamic inject |
| npm entry point | `"main": "index.js"` — файл не існує | `npm install` не дасть прямого `import` |
| TypeScript типи | Відсутні | Потрібно писати `.d.ts` вручну |
| Розмір | ~1.4 MB (unminified) | Обов'язково lazy loading |
| Залежності | Нуль | Перевага — немає конфліктів |

### 4.2 API (ключові операції)

```typescript
// Ініціалізація
const drakon = createDrakonWidget()
drakon.render(container, width, height, config)

// Завантаження діаграми
drakon.setDiagram(diagramId, diagramData, sender)

// Збереження
const json = drakon.exportJson()   // → зберегти у MinIO

// Resize
drakon.redraw()

// Cleanup
editSender.stop()
```

### 4.3 CSS ізоляція

`drakonwidget` очікує `box-sizing: content-box`. Tailwind перевизначає це через `box-sizing: border-box`. Потрібна CSS-ізоляція контейнера:

```css
.drakon-container {
  isolation: isolate;
  contain: layout style;
}
.drakon-container * {
  box-sizing: content-box;
}
```

### 4.4 Завантаження у Vite/React

```typescript
// Варіант 1: dynamic script inject (рекомендований)
await loadScript('/libs/drakonwidget.js')
const drakon = (window as any).createDrakonWidget()

// Варіант 2: Vite worker (складніший)
// Варіант 3: import() з side effects (потрібна обгортка)
```

Детально: [[exodus.pp.ua/drakon/ДОСЛІДЖЕННЯ_DRAKONWIDGET\|ДОСЛІДЖЕННЯ_DRAKONWIDGET]]

---

## 5. Файлова структура нових компонентів

```
src/
├── components/
│   └── agent/
│       ├── DrakonEditor.tsx          # Редактор діаграм агента (edit mode)
│       └── DrakonViewer.tsx          # Перегляд діаграми (read-only)
├── hooks/
│   └── useDrakonWidget.ts            # lifecycle: load script, create instance, cleanup
├── lib/
│   └── drakon/
│       ├── adapter.ts                # scriptLoader + createDrakonWidget wrapper
│       ├── types.ts                  # TypeScript інтерфейси: StoredDrakonDiagram, etc.
│       ├── themeAdapter.ts           # garden dark/light → drakon theme
│       └── diagramApi.ts             # API calls: GET/PUT через Worker
└── types/
    └── drakonwidget.d.ts             # TypeScript declarations для IIFE

public/
└── libs/
    └── drakonwidget.js               # Vendor copy (IIFE, ~1.4MB)
```

---

## 6. Маршрутизація (нові сторінки)

```
/agents                         → AgentsPage (список агентів)
/agents/:slug                   → AgentDetailPage (інфо + runs + proposals)
/agents/:slug/logic             → AgentLogicPage (DRAKON Viewer + Editor)
/agents/:slug/logic/:file       → AgentLogicFilePage (конкретна діаграма)
```

---

## 7. Інтеграція з Worker (Gateway)

Нові endpoints у Cloudflare Worker для роботи з агентами:

| Endpoint | Метод | Дія |
|----------|-------|-----|
| `/agents` | GET | Список агентів (MinIO list) |
| `/agents/:slug` | GET | Метадані агента + `_agent.md` |
| `/agents/:slug/drakon` | GET | Список діаграм агента |
| `/agents/:slug/drakon/:file` | GET | Завантажити `.drakon.json` |
| `/agents/:slug/drakon/:file` | PUT | Зберегти `.drakon.json` → тригер regeneration |
| `/agents/:slug/runs` | GET | Список runs |
| `/agents/:slug/runs/:runId` | GET | Деталі run + steps |

Всі endpoints захищені Owner JWT (A5 — Gateway як єдина точка входу).

---

## 8. Пріоритетність реалізації

### Phase 1: Read-only (Viewer)

1. `drakonwidget.js` у `public/libs/`
2. `useDrakonWidget.ts` — script loader + lifecycle
3. `DrakonViewer.tsx` — read-only embed
4. Worker endpoints: `GET /agents/:slug/drakon/*`
5. `AgentLogicPage` — сторінка перегляду логіки агента

### Phase 2: Editor

1. `DrakonEditor.tsx` — edit mode
2. Worker endpoint: `PUT /agents/:slug/drakon/:file`
3. Тригер regeneration (drakongen + agentExporter) у Worker
4. TypeScript `.d.ts` для drakonwidget API

### Phase 3: Agent Management

1. `AgentsPage` — список та статус агентів
2. `AgentDetailPage` — runs, proposals, memory overview
3. Trigger manual run: `POST /agents/:slug/run`

---

## Семантичні зв'язки

**Цей документ спирається на:**
- [[exodus.pp.ua/architecture/АРХІТЕКТУРНИЙ_КОРІНЬ\|АРХІТЕКТУРНИЙ_КОРІНЬ]] — A1 (MinIO), A3 (stateless runtime), A5 (Gateway), A6 (Frontend = projection)
- [[exodus.pp.ua/architecture/DRAKON_ІНТЕГРАЦІЯ_ТА_МОДЕЛЬ_ВИКОНАННЯ_АГЕНТА\|DRAKON_ІНТЕГРАЦІЯ_ТА_МОДЕЛЬ_ВИКОНАННЯ_АГЕНТА]] — повна специфікація DRAKON pipeline
- [[exodus.pp.ua/architecture/КОНТРАКТ_АГЕНТА_V1\|КОНТРАКТ_АГЕНТА_V1]] — структура папки агента у MinIO
- [[exodus.pp.ua/architecture/КАНОНІЧНА_МОДЕЛЬ_АВТОРИТЕТУ_СХОВИЩА\|КАНОНІЧНА_МОДЕЛЬ_АВТОРИТЕТУ_СХОВИЩА]] — write authority: тільки Worker може писати в MinIO

**Суміжні документи:**
- [[exodus.pp.ua/drakon/ДОСЛІДЖЕННЯ_DRAKONWIDGET\|ДОСЛІДЖЕННЯ_DRAKONWIDGET]] — детальний технічний аналіз бібліотеки
- [[exodus.pp.ua/drakon/СТРАТЕГІЯ_ІНТЕГРАЦІЇ\|СТРАТЕГІЯ_ІНТЕГРАЦІЇ]] — архітектурні рішення React-інтеграції (CSS scoping, lazy loading)
- [[exodus.pp.ua/drakon/ЧЕКЛИСТ_РЕАЛІЗАЦІЇ\|ЧЕКЛИСТ_РЕАЛІЗАЦІЇ]] — покроковий чеклист впровадження

---

*Цей документ замінює PROJECT_ANALYSIS_UA (2026-02-07), який описував Garden Bloom як Digital Garden SPA замість AI agent execution platform.*
